{% load static %}
{% load driver_extras %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driver Dashboard - Hospione</title>
<!-- Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<!-- Fonts and Icons -->
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&family=Raleway:wght@400;500;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<link rel="stylesheet" href="{% static 'passenger/css/global.css' %}">

<style>
/* Ola-like Dashboard Styles - Preserving Existing Color Theme */
:root {
    --primary-teal: #00A59E;
    --primary-cyan: #0EB9D3;
}

body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: 'Open Sans', sans-serif;
}

.driver-dashboard {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Top Navigation Bar */
.top-navbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 70px;
    background: linear-gradient(135deg, #00A59E, #0EB9D3);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 20px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.navbar-left {
    display: flex;
    align-items: center;
    gap: 15px;
}

.driver-avatar {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: #00A59E;
    font-size: 18px;
    border: 2px solid white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.driver-info {
    display: flex;
    flex-direction: column;
}

.driver-name {
    color: white;
    font-weight: 600;
    font-size: 16px;
    margin: 0;
}

.driver-status-text {
    color: rgba(255, 255, 255, 0.9);
    font-size: 12px;
    margin: 0;
}

.navbar-right {
    display: flex;
    align-items: center;
    gap: 20px;
}

.wallet-info {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    padding: 8px 15px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    color: white;
    font-weight: 600;
    font-size: 14px;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.wallet-icon {
    font-size: 16px;
}

/* Toggle Switch - Using Existing Theme */
.toggle-container {
    position: relative;
    display: inline-block;
}

.toggle-input {
    position: absolute;
    opacity: 0;
    width: 0;
    height: 0;
    pointer-events: none;
}

.toggle-label {
    position: relative;
    display: block;
    width: 64px;
    height: 32px;
    cursor: pointer;
}

.toggle-track {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 16px;
    transition: all 0.3s ease;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.toggle-thumb {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 28px;
    height: 28px;
    background-color: white;
    border-radius: 50%;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    z-index: 1;
}

.toggle-input:checked + .toggle-label .toggle-track {
    background: rgba(255, 255, 255, 0.5);
}

.toggle-input:checked + .toggle-label .toggle-thumb {
    transform: translateX(32px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

/* Map Container */
.map-container {
    position: fixed;
    top: 70px;
    left: 0;
    right: 0;
    bottom: 120px;
    background: #e5e7eb;
    overflow: hidden;
}

#driver-map {
    width: 100%;
    height: 100%;
    z-index: 1;
}

.map-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: #6b7280;
    z-index: 1000;
    background: white;
    padding: 20px 30px;
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

.map-loading i {
    font-size: 48px;
    margin-bottom: 10px;
    opacity: 0.5;
    color: #00A59E;
}

.location-error {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: #dc2626;
    z-index: 1000;
    background: white;
    padding: 20px 30px;
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    max-width: 80%;
}

.location-error i {
    font-size: 48px;
    margin-bottom: 10px;
}

/* Custom Driver Marker Icon */
.driver-icon-div {
    background: transparent;
    border: none;
}

.driver-icon {
    background: linear-gradient(135deg, #00A59E, #0EB9D3);
    border-radius: 50%;
    border: 4px solid white;
    box-shadow: 0 4px 12px rgba(0, 165, 158, 0.4);
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
}

/* Passenger Marker Icon */
.passenger-icon-div {
    background: transparent;
    border: none;
}

.passenger-marker-icon {
    background: #dc2626;
    border-radius: 50% 50% 50% 0;
    transform: rotate(-45deg);
    border: 4px solid white;
    box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
}

.passenger-marker-icon i {
    transform: rotate(45deg);
}

/* Route Info Card */
.route-info-card {
    z-index: 1000;
}

/* Toast Animation */
@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOutRight {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%);
        opacity: 0;
    }
}

/* Ride Request Notification Popup */
.ride-request-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(4px);
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.3s ease;
}

.ride-request-overlay.show {
    display: flex;
}

.ride-request-popup {
    background: white;
    border-radius: 25px;
    padding: 25px;
    max-width: 90%;
    width: 400px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    animation: slideUp 0.3s ease;
    position: relative;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideUp {
    from {
        transform: translateY(50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.popup-header {
    text-align: center;
    margin-bottom: 20px;
}

.countdown-timer {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: linear-gradient(135deg, #00A59E, #0EB9D3);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 15px;
    box-shadow: 0 4px 15px rgba(0, 165, 158, 0.3);
    color: white;
    font-size: 32px;
    font-weight: 700;
}

.countdown-text {
    font-size: 16px;
    font-weight: 600;
    color: #1f2937;
}

.passenger-info-section {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 20px 0;
    border-bottom: 1px solid #e5e7eb;
}

.passenger-avatar-popup {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: linear-gradient(135deg, #00A59E, #0EB9D3);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 24px;
}

.passenger-details-popup {
    flex: 1;
}

.passenger-name-popup {
    font-size: 20px;
    font-weight: 700;
    color: #1f2937;
    margin: 0 0 5px 0;
}

.passenger-rating-popup {
    display: flex;
    align-items: center;
    gap: 5px;
    color: #f59e0b;
    font-size: 14px;
    font-weight: 600;
}

.trip-details-section {
    padding: 20px 0;
}

.location-item-popup {
    display: flex;
    align-items: flex-start;
    gap: 15px;
    margin-bottom: 15px;
}

.location-icon-popup {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.location-item-popup.pickup .location-icon-popup {
    background: #dcfce7;
    color: #16a34a;
}

.location-item-popup.dropoff .location-icon-popup {
    background: #fee2e2;
    color: #dc2626;
}

.location-info-popup {
    flex: 1;
}

.location-label-popup {
    font-size: 12px;
    color: #6b7280;
    text-transform: uppercase;
    font-weight: 600;
    margin: 0 0 5px 0;
    letter-spacing: 0.5px;
}

.location-address-popup {
    font-size: 16px;
    color: #1f2937;
    font-weight: 600;
    margin: 0;
    line-height: 1.4;
}

.fare-section-popup {
    background: #f9fafb;
    border-radius: 15px;
    padding: 20px;
    margin: 20px 0;
}

.fare-item-popup {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid #e5e7eb;
}

.fare-item-popup:last-child {
    border-bottom: none;
}

.fare-label-popup {
    font-size: 14px;
    color: #6b7280;
    font-weight: 500;
}

.fare-amount-popup {
    font-size: 24px;
    font-weight: 700;
    color: #00A59E;
}

.popup-actions {
    display: flex;
    gap: 15px;
    margin-top: 25px;
}

.btn-popup {
    flex: 1;
    padding: 16px;
    border: none;
    border-radius: 15px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.btn-popup-reject {
    background: white;
    color: #dc2626;
    border: 2px solid #dc2626;
}

.btn-popup-reject:hover {
    background: #fee2e2;
    transform: translateY(-2px);
}

.btn-popup-accept {
    background: linear-gradient(135deg, #00A59E, #0EB9D3);
    color: white;
}

.btn-popup-accept:hover {
    background: linear-gradient(135deg, #0EB9D3, #00A59E);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 165, 158, 0.3);
}

.timeout-message {
    text-align: center;
    padding: 20px;
    color: #dc2626;
    font-weight: 600;
    display: none;
}

.timeout-message.show {
    display: block;
}

/* Bottom Status Card */
.bottom-status-card {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 120px;
    background: white;
    border-top-left-radius: 25px;
    border-top-right-radius: 25px;
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
    z-index: 999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #10b981;
    display: inline-block;
    margin-right: 8px;
    animation: blink 2s infinite;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.status-message {
    font-size: 18px;
    font-weight: 600;
    color: #1f2937;
    margin: 10px 0;
    text-align: center;
}

.status-submessage {
    font-size: 14px;
    color: #6b7280;
    text-align: center;
    margin-top: 5px;
}

.status-unavailable {
    color: #6b7280;
}

.status-unavailable .status-indicator {
    background: #9ca3af;
    animation: none;
}

/* Quick Actions removed - duplicate icons removed from map section */

/* Responsive Design */
@media (max-width: 768px) {
    .top-navbar {
        height: 60px;
        padding: 0 15px;
    }
    
    .driver-avatar {
        width: 40px;
        height: 40px;
        font-size: 16px;
    }
    
    .driver-name {
        font-size: 14px;
    }
    
    .driver-status-text {
        font-size: 11px;
    }
    
    .wallet-info {
        padding: 6px 12px;
        font-size: 12px;
    }
    
    .map-container {
        top: 60px;
        bottom: 100px;
    }
    
    .bottom-status-card {
        height: 100px;
        padding: 15px;
    }
    
    .status-message {
        font-size: 16px;
    }
    
    .status-submessage {
        font-size: 12px;
    }
}

/* Driver Arrived Button */
.driver-arrived-container {
    position: fixed;
    bottom: 140px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    animation: slideUpFade 0.3s ease-out;
}

.driver-arrived-btn {
    background: linear-gradient(135deg, #00A59E, #0EB9D3);
    color: white;
    border: none;
    padding: 16px 32px;
    border-radius: 50px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 4px 20px rgba(0, 165, 158, 0.4);
    display: flex;
    align-items: center;
    gap: 10px;
    transition: all 0.3s ease;
    min-width: 200px;
    justify-content: center;
}

.driver-arrived-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 25px rgba(0, 165, 158, 0.5);
    background: linear-gradient(135deg, #0EB9D3, #00A59E);
}

.driver-arrived-btn:active {
    transform: translateY(0);
}

.driver-arrived-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

.driver-arrived-btn i {
    font-size: 18px;
}

@keyframes slideUpFade {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

@media (max-width: 768px) {
    .driver-arrived-container {
        bottom: 120px;
        left: 20px;
        right: 20px;
        transform: none;
    }
    
    .driver-arrived-btn {
        width: 100%;
        min-width: auto;
    }
}

/* Menu Button */
.menu-button {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
}

.menu-button:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* Sidebar Menu (Hidden by default) */
.sidebar-menu {
    position: fixed;
    top: 70px;
    right: -300px;
    width: 300px;
    height: calc(100vh - 70px);
    background: white;
    box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
    z-index: 1001;
    transition: right 0.3s ease;
    overflow-y: auto;
}

.sidebar-menu.open {
    right: 0;
}

.menu-item {
    padding: 15px 20px;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    align-items: center;
    gap: 15px;
    color: #1f2937;
    text-decoration: none;
    transition: all 0.3s ease;
}

.menu-item:hover {
    background: #f3f4f6;
    color: #00A59E;
}

.menu-item i {
    width: 20px;
    color: #00A59E;
}
</style>
</head>
<body>
<div class="driver-dashboard">
    <!-- Top Navigation Bar -->
    <nav class="top-navbar">
        <div class="navbar-left">
            <div class="driver-avatar">
                {{ driver.first_name|first }}{{ driver.last_name|first }}
      </div>
            <div class="driver-info">
                <p class="driver-name">{{ driver.first_name }} {{ driver.last_name }}</p>
                <p class="driver-status-text" id="availability-text">
                    {% if driver.availability %}Online{% else %}Offline{% endif %}
                </p>
    </div>
    </div>
        
        <div class="navbar-right">
            <div class="wallet-info">
                <i class="fas fa-wallet wallet-icon"></i>
                <span>₹{{ total_earnings|floatformat:0 }}</span>
    </div>
            
      <div class="toggle-container">
        <input type="checkbox" id="availability-toggle" class="toggle-input" {% if driver.availability %}checked{% endif %}>
        <label for="availability-toggle" class="toggle-label">
          <span class="toggle-track"></span>
          <span class="toggle-thumb"></span>
        </label>
      </div>
            
            <button class="menu-button" onclick="toggleSidebar()">
                <i class="fas fa-bars"></i>
            </button>
        </div>
    </nav>

    <!-- Map Container -->
    <div class="map-container">
        <div id="driver-map"></div>
        <div id="map-loading" class="map-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <div>Loading map...</div>
        </div>
        <div id="location-error" class="location-error" style="display: none;">
            <i class="fas fa-exclamation-triangle"></i>
            <div>Location access denied. Please enable location services.</div>
    </div>
  </div>

    <!-- Bottom Status Card -->
    <div class="bottom-status-card" id="status-card">
        <div class="status-message" id="status-message">
            {% if driver.availability %}
                <span class="status-indicator"></span>
                You're Online
            {% else %}
                <span class="status-indicator"></span>
                You're Offline
            {% endif %}
    </div>
        <div class="status-submessage" id="status-submessage">
            {% if driver.availability %}
                Waiting for Ride Requests
            {% else %}
                Turn on availability to start receiving rides
            {% endif %}
    </div>
    </div>

    <!-- Driver Arrived Button (shown after ride acceptance) -->
    <div id="driver-arrived-button-container" class="driver-arrived-container" style="display: none;">
        <button id="driver-arrived-btn" class="driver-arrived-btn">
            <i class="fas fa-map-marker-alt"></i>
            <span>Driver Arrived</span>
        </button>
    </div>

    <!-- Quick Actions removed - icons are already available in sidebar menu -->

    <!-- Sidebar Menu -->
    <div class="sidebar-menu" id="sidebar-menu">
        <a href="{% url 'driver_homepage' %}" class="menu-item">
            <i class="fas fa-home"></i>
            <span>Home</span>
        </a>
        <a href="{% url 'driver:driver_rides' %}" class="menu-item">
            <i class="fas fa-list"></i>
            <span>My Rides</span>
        </a>
        <!-- Removed Ride Requests menu item - ride requests are handled on dashboard -->
        <a href="{% url 'driver:driver_earnings' %}" class="menu-item">
            <i class="fas fa-rupee-sign"></i>
            <span>Earnings</span>
        </a>
        <a href="{% url 'driver_rating_page' %}" class="menu-item">
            <i class="fas fa-star"></i>
            <span>Ratings</span>
        </a>
        <a href="{% url 'driver:driver_profile' driver.driver_id %}" class="menu-item">
            <i class="fas fa-user"></i>
            <span>Profile</span>
        </a>
        <a href="{% url 'logout' %}" class="menu-item">
            <i class="fas fa-sign-out-alt"></i>
            <span>Logout</span>
        </a>
    </div>
  </div>

<!-- Ride Request Notification Popup -->
<div id="ride-request-overlay" class="ride-request-overlay" onclick="if(event.target === this) closeRideRequest()">
    <div class="ride-request-popup" onclick="event.stopPropagation()">
        <div class="popup-header">
            <div class="countdown-timer" id="countdown-timer">120</div>
            <p class="countdown-text">New Ride Request</p>
    </div>

        <div class="passenger-info-section">
            <div class="passenger-avatar-popup">
                <i class="fas fa-user"></i>
    </div>
            <div class="passenger-details-popup">
                <h3 class="passenger-name-popup" id="popup-passenger-name">John Doe</h3>
                <div class="passenger-rating-popup">
                    <i class="fas fa-star"></i>
                    <span id="popup-passenger-rating">4.8</span>
    </div>
    </div>
  </div>

        <div class="trip-details-section">
            <div class="location-item-popup pickup">
                <div class="location-icon-popup">
                    <i class="fas fa-map-marker-alt"></i>
        </div>
                <div class="location-info-popup">
                    <p class="location-label-popup">Pickup</p>
                    <p class="location-address-popup" id="popup-pickup">123 Main Street, City</p>
      </div>
    </div>

            <div class="location-item-popup dropoff">
                <div class="location-icon-popup">
                    <i class="fas fa-flag-checkered"></i>
          </div>
                <div class="location-info-popup">
                    <p class="location-label-popup">Dropoff</p>
                    <p class="location-address-popup" id="popup-dropoff">456 Park Avenue, City</p>
          </div>
        </div>
      </div>

        <div class="fare-section-popup">
            <div class="fare-item-popup">
                <span class="fare-label-popup">Estimated Fare</span>
                <span class="fare-amount-popup" id="popup-fare">₹250</span>
          </div>
            <div class="fare-item-popup">
                <span class="fare-label-popup">Service Type</span>
                <span class="fare-label-popup" id="popup-service-type">Standard</span>
    </div>
  </div>

        <div class="timeout-message" id="timeout-message">
            <i class="fas fa-clock"></i>
            <p>Request timed out</p>
        </div>

        <div class="popup-actions" id="popup-actions">
            <button class="btn-popup btn-popup-reject" onclick="rejectRideRequest()">
                <i class="fas fa-times"></i>
                Reject
            </button>
            <button class="btn-popup btn-popup-accept" onclick="acceptRideRequest()">
                <i class="fas fa-check"></i>
                Accept
            </button>
      </div>
    </div>
  </div>

<!-- Ride Completed Notification Popup -->
<div id="ride-completed-overlay" class="ride-request-overlay" onclick="if(event.target === this) closeRideCompleted()">
    <div class="ride-request-popup" onclick="event.stopPropagation()">
        <div class="popup-header">
            <div class="countdown-timer" style="background: linear-gradient(135deg, #10b981, #059669);">
                <i class="fas fa-check-circle" style="font-size: 40px;"></i>
            </div>
            <p class="countdown-text">Ride Completed</p>
    </div>

        <div class="passenger-info-section">
            <div class="passenger-avatar-popup">
                <i class="fas fa-user"></i>
    </div>
            <div class="passenger-details-popup">
                <h3 class="passenger-name-popup" id="completed-popup-passenger-name">Passenger Name</h3>
                <div class="passenger-rating-popup" style="display: none;">
                    <i class="fas fa-star"></i>
                    <span id="completed-popup-passenger-rating">4.8</span>
    </div>
    </div>
  </div>

        <div class="trip-details-section">
            <div class="location-item-popup pickup">
                <div class="location-icon-popup">
                    <i class="fas fa-map-marker-alt"></i>
        </div>
                <div class="location-info-popup">
                    <p class="location-label-popup">Pickup</p>
                    <p class="location-address-popup" id="completed-popup-pickup">Pickup Location</p>
      </div>
    </div>

            <div class="location-item-popup dropoff">
                <div class="location-icon-popup">
                    <i class="fas fa-flag-checkered"></i>
          </div>
                <div class="location-info-popup">
                    <p class="location-label-popup">Dropoff</p>
                    <p class="location-address-popup" id="completed-popup-dropoff">Dropoff Location</p>
          </div>
        </div>
      </div>

        <div class="fare-section-popup">
            <div class="fare-item-popup">
                <span class="fare-label-popup">Total Fare</span>
                <span class="fare-amount-popup" id="completed-popup-fare">₹0</span>
          </div>
            <div class="fare-item-popup" id="completed-popup-distance-container" style="display: none;">
                <span class="fare-label-popup">Distance</span>
                <span class="fare-label-popup" id="completed-popup-distance">-</span>
    </div>
            <div class="fare-item-popup" id="completed-popup-duration-container" style="display: none;">
                <span class="fare-label-popup">Duration</span>
                <span class="fare-label-popup" id="completed-popup-duration">-</span>
    </div>
            <div class="fare-item-popup">
                <span class="fare-label-popup">Service Type</span>
                <span class="fare-label-popup" id="completed-popup-service-type">Standard</span>
    </div>
            <div class="fare-item-popup">
                <span class="fare-label-popup">Payment Mode</span>
                <span class="fare-label-popup" id="completed-popup-payment-mode">Cash</span>
    </div>
  </div>

        <div class="popup-actions">
            <button class="btn-popup btn-popup-accept" onclick="closeRideCompleted()" style="width: 100%;">
                <i class="fas fa-check"></i>
                OK
            </button>
      </div>
    </div>
  </div>

<!-- Leaflet.js JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Leaflet Routing Machine -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.js"></script>

  <!-- Availability Toggle Script -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const toggle = document.getElementById('availability-toggle');
      const statusText = document.getElementById('availability-text');
        const statusMessage = document.getElementById('status-message');
        const statusSubmessage = document.getElementById('status-submessage');
        const statusCard = document.getElementById('status-card');

      toggle.addEventListener('change', () => {
        const availability = toggle.checked;

        // Optimistic UI update
            updateStatusUI(availability);

        fetch("{% url 'driver:toggle_availability' %}", {
          method: "POST",
          headers: {
            "X-CSRFToken": "{{ csrf_token }}",
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: `availability=${availability}`
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
                    updateStatusUI(data.availability);
          } else {
            // Revert on failure
            toggle.checked = !availability;
                    updateStatusUI(!availability);
            alert("Failed to update availability. Please try again.");
          }
        })
        .catch(err => {
          console.error("Error updating availability:", err);
          // Revert on error
          toggle.checked = !availability;
                updateStatusUI(!availability);
          alert("Network error. Please check your connection and try again.");
        });
      });

        function updateStatusUI(isAvailable) {
            if (isAvailable) {
                statusText.textContent = "Online";
                statusMessage.innerHTML = '<span class="status-indicator"></span>You\'re Online';
                statusSubmessage.textContent = "Waiting for Ride Requests";
                statusCard.classList.remove('status-unavailable');
            } else {
                statusText.textContent = "Offline";
                statusMessage.innerHTML = '<span class="status-indicator"></span>You\'re Offline';
                statusSubmessage.textContent = "Turn on availability to start receiving rides";
                statusCard.classList.add('status-unavailable');
            }
        }
    });

    function toggleSidebar() {
        const sidebar = document.getElementById('sidebar-menu');
        sidebar.classList.toggle('open');
    }

    // Close sidebar when clicking outside
    document.addEventListener('click', (e) => {
        const sidebar = document.getElementById('sidebar-menu');
        const menuButton = document.querySelector('.menu-button');
        
        if (!sidebar.contains(e.target) && !menuButton.contains(e.target)) {
            sidebar.classList.remove('open');
        }
    });
  </script>

<!-- Map and Ride Request Notification Script -->
<script>
    // Map and Location Tracking
    let map = null;
    let driverMarker = null;
    let watchId = null;
    let currentLat = null;
    let currentLng = null;

    // Ride Request Notification
    let notificationSound = null;
    let countdownInterval = null;
    let countdownTime = 120; // 120 seconds (2 minutes)
    let currentRideRequest = null;
    let processedRequestIds = new Set(); // Track which requests we've already shown
    
    // Map route and markers
    let passengerMarker = null;
    let dropoffMarker = null;
    let routePolyline = null;
    let routeControl = null; // Leaflet Routing Machine control
    let routeInfoCard = null;
    
    // Active booking tracking
    const serverActiveBookingId = {{ active_booking.booking_id|default:"null" }};
    const serverActiveBookingStatus = {% if active_booking %}"{{ active_booking.status }}"{% else %}null{% endif %};
    let currentBookingId = null;
    let isRideActive = false; // Track if ride is active (started)
    let rideTrackingWatchId = null; // Separate watch ID for ride tracking
    let ridePinVerified = false;
    let ridePinLockedUntil = null;
    
    // Stored ride coordinates (from ride acceptance)
    let storedPickupCoords = null; // [lat, lng]
    let storedDropoffCoords = null; // [lat, lng]
    let storedPickupAddress = null;
    let storedDropoffAddress = null;

    // Initialize Map
    function initMap() {
        // Try to get current location first
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    currentLat = position.coords.latitude;
                    currentLng = position.coords.longitude;
                    setupMap(currentLat, currentLng);
                    startLocationTracking();
                },
                (error) => {
                    console.error('Error getting location:', error);
                    // Default to a central location (e.g., Mumbai)
                    currentLat = 19.0760;
                    currentLng = 72.8777;
                    setupMap(currentLat, currentLng);
                    document.getElementById('location-error').style.display = 'block';
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        } else {
            // Fallback if geolocation not supported
            currentLat = 19.0760;
            currentLng = 72.8777;
            setupMap(currentLat, currentLng);
            document.getElementById('location-error').style.display = 'block';
        }
    }

    function setupMap(lat, lng) {
        // Hide loading message
        document.getElementById('map-loading').style.display = 'none';

        // Initialize map
        map = L.map('driver-map').setView([lat, lng], 15);

        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        // Create custom driver icon
        const driverIcon = L.divIcon({
            className: 'driver-icon-div',
            html: '<div class="driver-icon"><i class="fas fa-car"></i></div>',
            iconSize: [50, 50],
            iconAnchor: [25, 25]
        });

        // Add driver marker
        driverMarker = L.marker([lat, lng], { icon: driverIcon }).addTo(map);
    }

    function startLocationTracking() {
        if (!navigator.geolocation) {
            console.error('Geolocation not supported');
            return;
        }

        const options = {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
        };

        watchId = navigator.geolocation.watchPosition(
            (position) => {
                currentLat = position.coords.latitude;
                currentLng = position.coords.longitude;

                if (driverMarker) {
                    // Smoothly move marker to new position
                    driverMarker.setLatLng([currentLat, currentLng]);
                    // Only pan map if ride is not active (to avoid conflicting with route following)
                    if (!isRideActive) {
                        map.setView([currentLat, currentLng], map.getZoom(), { animate: true, duration: 1 });
                    }
                } else {
                    // Create marker if it doesn't exist
                    const driverIcon = L.divIcon({
                        className: 'driver-icon-div',
                        html: '<div class="driver-icon"><i class="fas fa-car"></i></div>',
                        iconSize: [50, 50],
                        iconAnchor: [25, 25]
                    });
                    driverMarker = L.marker([currentLat, currentLng], { icon: driverIcon }).addTo(map);
                }

                // Hide error message if location is now available
                document.getElementById('location-error').style.display = 'none';
            },
            (error) => {
                console.error('Location tracking error:', error);
                if (error.code === error.PERMISSION_DENIED) {
                    document.getElementById('location-error').style.display = 'block';
                }
            },
            options
        );
    }

    // Geocode an address to get coordinates
    async function geocodeAddress(address) {
        if (!address) {
            throw new Error('No address provided');
        }
        
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`;
        console.log('Geocoding address:', address);
        
        try {
            const response = await fetch(url, {
                headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'DropMeDriverApp/1.0'
                }
            });
            
            if (!response.ok) {
                throw new Error(`Geocoding failed: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (!Array.isArray(data) || data.length === 0) {
                throw new Error('No results found for address');
            }
            
            const lat = parseFloat(data[0].lat);
            const lng = parseFloat(data[0].lon);
            
            if (isNaN(lat) || isNaN(lng)) {
                throw new Error('Invalid coordinates from geocoding');
            }
            
            console.log('Geocoded address:', address, '->', [lat, lng]);
            return { lat, lng, display_name: data[0].display_name };
        } catch (error) {
            console.error('Geocoding error:', error);
            throw error;
        }
    }

    // Calculate distance between two coordinates (Haversine formula) - moved up for use in validation
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth's radius in km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    // Validate coordinates are reasonable for India region (rough bounds)
    function isValidIndiaCoordinate(lat, lng) {
        // India approximate bounds: lat 6.5-37, lng 68-97
        // But we'll be more lenient: lat 5-40, lng 65-100
        const isValid = lat >= 5 && lat <= 40 && lng >= 65 && lng <= 100;
        if (!isValid) {
            console.warn('Coordinate outside India region:', { lat, lng });
        }
        return isValid;
    }

    // Validate coordinates are reasonable (not in ocean, valid ranges)
    function areReasonableCoordinates(lat, lng) {
        // Check for null, undefined, or NaN
        if (lat === null || lat === undefined || lng === null || lng === undefined || 
            isNaN(lat) || isNaN(lng)) {
            return false;
        }
        
        // Reject obviously invalid coordinates like (0,0) which is in the ocean
        if (lat === 0 && lng === 0) {
            console.warn('Rejecting coordinates (0,0) - invalid location');
            return false;
        }
        
        // Basic global bounds
        if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
            return false;
        }
        
        // For now, check if they're in reasonable range for India
        // If driver is in India, passenger should also be nearby
        if (currentLat && currentLng) {
            const driverLat = parseFloat(currentLat);
            const driverLng = parseFloat(currentLng);
            
            // If driver is in India region, passenger should be within reasonable distance
            if (isValidIndiaCoordinate(driverLat, driverLng)) {
                // Passenger should also be in India or nearby
                if (!isValidIndiaCoordinate(lat, lng)) {
                    // Check if distance is reasonable (not thousands of km)
                    const distance = calculateDistance(driverLat, driverLng, lat, lng);
                    if (distance > 500) { // More than 500km is suspicious for local rides
                        console.warn('Unusually large distance detected:', distance, 'km');
                        return false;
                    }
                }
            }
        }
        
        return true;
    }

    // Ride Request Notification Functions
    function createNotificationSound() {
        // Create a simple notification sound using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = 800;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
    }

    function showRideRequest(rideData) {
        // Don't show if already processed
        if (processedRequestIds.has(rideData.id)) {
            return;
        }
        
        // Validate and parse coordinates
        const pickupLat = rideData.pickupLat !== null && rideData.pickupLat !== undefined ? parseFloat(rideData.pickupLat) : null;
        const pickupLng = rideData.pickupLng !== null && rideData.pickupLng !== undefined ? parseFloat(rideData.pickupLng) : null;
        
        // Log coordinate validation
        console.log('Ride request data received:', {
            id: rideData.id,
            pickupLat: pickupLat,
            pickupLng: pickupLng,
            pickupLatRaw: rideData.pickupLat,
            pickupLngRaw: rideData.pickupLng,
            pickup: rideData.pickup
        });
        
        // Validate coordinates are valid numbers
        if (isNaN(pickupLat) || isNaN(pickupLng) || pickupLat === null || pickupLng === null) {
            console.error('Invalid pickup coordinates:', { pickupLat, pickupLng });
        }
        
        // Store validated coordinates back in rideData
        rideData.pickupLat = pickupLat;
        rideData.pickupLng = pickupLng;
        
        // Parse and validate dropoff coordinates
        const dropoffLat = rideData.dropoffLat !== null && rideData.dropoffLat !== undefined ? parseFloat(rideData.dropoffLat) : null;
        const dropoffLng = rideData.dropoffLng !== null && rideData.dropoffLng !== undefined ? parseFloat(rideData.dropoffLng) : null;
        
        // Store coordinates immediately when ride request is shown (as backup)
        // Only store if coordinates are valid and reasonable
        if (pickupLat !== null && pickupLng !== null && !isNaN(pickupLat) && !isNaN(pickupLng)) {
            if (areReasonableCoordinates(pickupLat, pickupLng)) {
                storedPickupCoords = [pickupLat, pickupLng];
                storedPickupAddress = rideData.pickup || 'Pickup Location';
                console.log('✅ Stored pickup coordinates from ride request:', storedPickupCoords);
            } else {
                console.warn('⚠️ Pickup coordinates from ride request failed validation:', [pickupLat, pickupLng]);
            }
        }
        
        if (dropoffLat !== null && dropoffLng !== null && !isNaN(dropoffLat) && !isNaN(dropoffLng)) {
            if (areReasonableCoordinates(dropoffLat, dropoffLng)) {
                storedDropoffCoords = [dropoffLat, dropoffLng];
                storedDropoffAddress = rideData.dropoff || 'Dropoff Location';
                console.log('✅ Stored dropoff coordinates from ride request:', storedDropoffCoords);
            } else {
                console.warn('⚠️ Dropoff coordinates from ride request failed validation:', [dropoffLat, dropoffLng]);
            }
        }
        
        currentRideRequest = rideData;
        countdownTime = 120; // Reset countdown to 120 seconds (2 minutes)

        // Update popup content
        document.getElementById('popup-passenger-name').textContent = rideData.passengerName || 'Passenger';
        document.getElementById('popup-passenger-rating').textContent = rideData.rating || '4.5';
        document.getElementById('popup-pickup').textContent = rideData.pickup || 'Pickup Location';
        document.getElementById('popup-dropoff').textContent = rideData.dropoff || 'Dropoff Location';
        document.getElementById('popup-fare').textContent = '₹' + (rideData.fare || '0');
        document.getElementById('popup-service-type').textContent = rideData.serviceType || 'Standard';

        // Show popup
        const overlay = document.getElementById('ride-request-overlay');
        overlay.classList.add('show');

        // Play sound
        createNotificationSound();

        // Start countdown
        startCountdown();

        // Show actions, hide timeout message
        document.getElementById('popup-actions').style.display = 'flex';
        document.getElementById('timeout-message').classList.remove('show');
        
        // Mark as processed
        processedRequestIds.add(rideData.id);
    }

    function startCountdown() {
        const timerElement = document.getElementById('countdown-timer');
        timerElement.textContent = countdownTime;

        if (countdownInterval) {
            clearInterval(countdownInterval);
        }

        countdownInterval = setInterval(() => {
            countdownTime--;
            timerElement.textContent = countdownTime;

            if (countdownTime <= 0) {
                clearInterval(countdownInterval);
                handleTimeout();
            }
        }, 1000);
    }

    function handleTimeout() {
        // Hide actions
        document.getElementById('popup-actions').style.display = 'none';
        
        // Show timeout message
        document.getElementById('timeout-message').classList.add('show');

        // Auto-close after 3 seconds
        setTimeout(() => {
            closeRideRequest();
        }, 3000);
    }

    function acceptRideRequest() {
        if (!currentRideRequest) {
            console.error('No current ride request to accept');
            return;
        }

        // Stop countdown
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }

        // Store ride data before closing popup
        const rideData = { ...currentRideRequest };
        
        // Validate and parse coordinates
        const pickupLat = rideData.pickupLat !== null && rideData.pickupLat !== undefined ? parseFloat(rideData.pickupLat) : null;
        const pickupLng = rideData.pickupLng !== null && rideData.pickupLng !== undefined ? parseFloat(rideData.pickupLng) : null;
        const dropoffLat = rideData.dropoffLat !== null && rideData.dropoffLat !== undefined ? parseFloat(rideData.dropoffLat) : null;
        const dropoffLng = rideData.dropoffLng !== null && rideData.dropoffLng !== undefined ? parseFloat(rideData.dropoffLng) : null;
        const driverLat = currentLat ? parseFloat(currentLat) : null;
        const driverLng = currentLng ? parseFloat(currentLng) : null;
        
        // Store pickup and dropoff coordinates for later use (when "Start Ride" is clicked)
        // Only store if coordinates are valid and reasonable
        if (pickupLat !== null && pickupLng !== null && !isNaN(pickupLat) && !isNaN(pickupLng)) {
            if (areReasonableCoordinates(pickupLat, pickupLng)) {
                storedPickupCoords = [pickupLat, pickupLng];
                storedPickupAddress = rideData.pickup || 'Pickup Location';
                console.log('✅ Stored pickup coordinates:', storedPickupCoords, 'Address:', storedPickupAddress);
            } else {
                console.warn('⚠️ Pickup coordinates failed validation, not storing:', [pickupLat, pickupLng]);
            }
        } else {
            console.warn('⚠️ Pickup coordinates are null/NaN, not storing:', { pickupLat, pickupLng });
        }
        
        if (dropoffLat !== null && dropoffLng !== null && !isNaN(dropoffLat) && !isNaN(dropoffLng)) {
            if (areReasonableCoordinates(dropoffLat, dropoffLng)) {
                storedDropoffCoords = [dropoffLat, dropoffLng];
                storedDropoffAddress = rideData.dropoff || 'Dropoff Location';
                console.log('✅ Stored dropoff coordinates:', storedDropoffCoords, 'Address:', storedDropoffAddress);
            } else {
                console.warn('⚠️ Dropoff coordinates failed validation, not storing:', [dropoffLat, dropoffLng]);
            }
        } else {
            console.warn('⚠️ Dropoff coordinates are null/NaN, not storing:', { dropoffLat, dropoffLng });
        }

        // Log coordinate validation
        console.log('Accepting ride request:', {
            rideId: rideData.id,
            driverCoords: driverLat && driverLng ? [driverLat, driverLng] : 'Not available',
            passengerCoords: pickupLat && pickupLng ? [pickupLat, pickupLng] : 'Not available',
            pickupAddress: rideData.pickup
        });

        // Close popup immediately for better UX
        closeRideRequest();

        // Function to get passenger coordinates with fallback to geocoding
        async function getPassengerCoordinates() {
            const pickupAddress = rideData.pickup;
            
            // First, try to use provided coordinates if they're valid
            if (pickupLat !== null && pickupLng !== null && !isNaN(pickupLat) && !isNaN(pickupLng)) {
                // Validate coordinates are reasonable
                if (areReasonableCoordinates(pickupLat, pickupLng)) {
                    console.log('Using provided coordinates:', [pickupLat, pickupLng]);
                    return [pickupLat, pickupLng];
                } else {
                    console.warn('Provided coordinates seem invalid/unreasonable, geocoding address instead');
                }
            }
            
            // If coordinates are invalid or missing, geocode the pickup address
            if (pickupAddress) {
                try {
                    console.log('Geocoding pickup address (coordinates invalid/missing):', pickupAddress);
                    const geocoded = await geocodeAddress(pickupAddress);
                    return [geocoded.lat, geocoded.lng];
                } catch (error) {
                    console.error('Geocoding failed:', error);
                    // Fall back to provided coordinates even if they seem wrong
                    if (pickupLat !== null && pickupLng !== null && !isNaN(pickupLat) && !isNaN(pickupLng)) {
                        console.warn('Using provided coordinates as last resort (may be incorrect):', [pickupLat, pickupLng]);
                        return [pickupLat, pickupLng];
                    }
                }
            }
            
            // Last resort: use mock coordinates near driver
            console.warn('No valid coordinates or address, using fallback');
            return null;
        }

        // Get passenger coordinates with geocoding fallback
        getPassengerCoordinates().then(passengerCoords => {
            if (!passengerCoords) {
                // No valid coordinates available
                console.error('Could not determine passenger pickup location');
                showToast('Unable to determine pickup location. Please try again.', 'error');
                return;
            }

            if (driverLat !== null && driverLng !== null && !isNaN(driverLat) && !isNaN(driverLng)) {
                console.log('Final coordinates for route:', {
                    driver: [driverLat, driverLng],
                    passenger: passengerCoords,
                    pickupAddress: rideData.pickup
                });
                
                // Draw route with validated coordinates
                drawRouteToPassenger(
                    [driverLat, driverLng],
                    passengerCoords,
                    rideData.pickup || 'Pickup Location'
                );
            } else {
                console.error('Driver coordinates not available');
                showToast('Driver location not available. Please enable location services.', 'error');
            }
        }).catch(error => {
            console.error('Error getting passenger coordinates:', error);
            showToast('Error determining pickup location', 'error');
        });

        // Send AJAX request to accept the ride (non-blocking)
        // Use relative URL to avoid CORS issues
        const acceptUrl = "{% url 'driver:accept_ride' 0 %}".replace('0', rideData.id);
        console.log('Sending accept request to:', acceptUrl);
        
        // Get CSRF token from cookie
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        const csrfToken = getCookie('csrftoken') || '{{ csrf_token }}';
        
        fetch(acceptUrl, {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: `csrfmiddlewaretoken=${encodeURIComponent(csrfToken)}`,
            redirect: 'manual', // Don't follow redirects automatically
            credentials: 'same-origin', // Include cookies for authentication
            mode: 'same-origin' // Explicitly set to same-origin to avoid CORS
        })
        .then(response => {
            console.log('Accept ride response:', {
                status: response.status,
                statusText: response.statusText,
                ok: response.ok,
                redirected: response.redirected,
                url: response.url
            });
            
            // Handle success (200-299) or redirect (300-399)
            if (response.ok || (response.status >= 300 && response.status < 400)) {
                // Try to parse JSON response if available (AJAX request)
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    response.clone().json().then(data => {
                        if (data.booking_id) {
                            currentBookingId = data.booking_id;
                            console.log('Booking ID received from accept response:', currentBookingId);
                        }
                        console.log('Ride accepted successfully');
                        showToast('Ride accepted successfully!', 'success');
                        showDriverArrivedButton();
                        updateStatusCard('Ride Accepted', 'Heading to pickup location');
                    }).catch(() => {
                        // If JSON parsing fails, treat as redirect
                        handleAcceptSuccess(rideData.id);
                    });
                } else {
                    // Redirect response - fetch booking_id separately
                    handleAcceptSuccess(rideData.id);
                }
            } else if (response.status === 0) {
                // Status 0 usually means network error or CORS issue
                console.warn('Network error or CORS issue (status 0). Ride may still be accepted on server.');
                showToast('Ride accepted locally. Please check connection.', 'info');
            } else {
                console.warn('Ride acceptance returned non-ok status:', response.status, response.statusText);
                // Try to read response body for more details
                response.text().then(text => {
                    console.warn('Response body:', text);
                }).catch(() => {});
                showToast('Ride accepted! Map updated.', 'success');
            }
        })
        .catch(error => {
            console.error('Error accepting ride:', error);
            // Check if it's a network error
            if (error.message && error.message.includes('fetch')) {
                console.error('Network error - check internet connection or CORS settings');
            }
            showToast('Ride accepted locally. Syncing with server...', 'info');
        });
    }

    function rejectRideRequest() {
        if (!currentRideRequest) return;

        // Stop countdown
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }

        // Close popup immediately
        closeRideRequest();

        // Send AJAX request to reject the ride (non-blocking)
        fetch("{% url 'driver:reject_ride' 0 %}".replace('0', currentRideRequest.id), {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: 'csrfmiddlewaretoken={{ csrf_token }}',
            redirect: 'manual'
        })
        .then(response => {
            console.log('Ride rejected successfully');
            showToast('Ride rejected', 'info');
        })
        .catch(error => {
            console.error('Error rejecting ride (non-blocking):', error);
            // Don't show alert, just log
        });
    }

    // Show non-blocking toast notification
    function showToast(message, type = 'info') {
        // Remove existing toast if any
        const existingToast = document.getElementById('toast-notification');
        if (existingToast) {
            existingToast.remove();
        }

        // Create toast element
        const toast = document.createElement('div');
        toast.id = 'toast-notification';
        toast.style.cssText = `
            position: fixed;
            top: 90px;
            right: 20px;
            background: ${type === 'success' ? '#10b981' : type === 'error' ? '#dc2626' : '#3b82f6'};
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 2001;
            animation: slideInRight 0.3s ease;
            max-width: 300px;
            font-size: 14px;
            font-weight: 500;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);

        // Auto-remove after 3 seconds
        setTimeout(() => {
            toast.style.animation = 'slideOutRight 0.3s ease';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    function closeRideRequest() {
        const overlay = document.getElementById('ride-request-overlay');
        overlay.classList.remove('show');
        
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }

        // Don't clear currentRideRequest here - we need it for storing coordinates
        // currentRideRequest = null;
        countdownTime = 120;
    }

    // Show ride completed notification popup
    function showRideCompletedPopup(data) {
        const overlay = document.getElementById('ride-completed-overlay');
        if (!overlay) {
            console.error('Ride completed overlay not found');
            return;
        }

        // Populate popup with ride data
        document.getElementById('completed-popup-passenger-name').textContent = data.passengerName || 'Passenger';
        document.getElementById('completed-popup-pickup').textContent = data.pickup || 'N/A';
        document.getElementById('completed-popup-dropoff').textContent = data.dropoff || 'N/A';
        document.getElementById('completed-popup-fare').textContent = `₹${parseFloat(data.fare || 0).toFixed(2)}`;
        document.getElementById('completed-popup-service-type').textContent = data.serviceType || 'Standard';
        document.getElementById('completed-popup-payment-mode').textContent = data.paymentMode || 'Cash';

        // Show distance if available
        const distanceContainer = document.getElementById('completed-popup-distance-container');
        const distanceElement = document.getElementById('completed-popup-distance');
        if (data.distance && parseFloat(data.distance) > 0) {
            distanceElement.textContent = `${parseFloat(data.distance).toFixed(2)} km`;
            distanceContainer.style.display = 'flex';
        } else {
            distanceContainer.style.display = 'none';
        }

        // Show duration if available
        const durationContainer = document.getElementById('completed-popup-duration-container');
        const durationElement = document.getElementById('completed-popup-duration');
        if (data.duration && parseInt(data.duration) > 0) {
            const minutes = parseInt(data.duration);
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            if (hours > 0) {
                durationElement.textContent = `${hours}h ${mins}m`;
            } else {
                durationElement.textContent = `${mins} min`;
            }
            durationContainer.style.display = 'flex';
        } else {
            durationContainer.style.display = 'none';
        }

        // Show the popup
        overlay.classList.add('show');
    }

    // Close ride completed notification popup
    function closeRideCompleted() {
        const overlay = document.getElementById('ride-completed-overlay');
        if (overlay) {
            overlay.classList.remove('show');
        }
        
        // Reset dashboard to waiting mode after closing popup
        setTimeout(() => {
            updateStatusCard('Waiting for Rides', 'You\'re online and ready to accept ride requests');
            // Clear the completed button container
            const container = document.getElementById('driver-arrived-button-container');
            if (container) {
                container.innerHTML = '';
            }
        }, 300);
    }

    // Draw route from driver to passenger pickup location
    function drawRouteToPassenger(driverCoords, passengerCoords, pickupAddress) {
        if (!map) {
            console.error('Map not initialized');
            return;
        }

        // Validate coordinates
        if (!Array.isArray(driverCoords) || driverCoords.length !== 2 ||
            !Array.isArray(passengerCoords) || passengerCoords.length !== 2) {
            console.error('Invalid coordinate arrays:', { driverCoords, passengerCoords });
            return;
        }

        const driverLat = parseFloat(driverCoords[0]);
        const driverLng = parseFloat(driverCoords[1]);
        const passengerLat = parseFloat(passengerCoords[0]);
        const passengerLng = parseFloat(passengerCoords[1]);

        if (isNaN(driverLat) || isNaN(driverLng) || isNaN(passengerLat) || isNaN(passengerLng)) {
            console.error('Invalid coordinate values:', {
                driverCoords,
                passengerCoords,
                parsed: { driverLat, driverLng, passengerLat, passengerLng }
            });
            return;
        }

        // Ensure coordinates are in valid range
        if (driverLat < -90 || driverLat > 90 || driverLng < -180 || driverLng > 180 ||
            passengerLat < -90 || passengerLat > 90 || passengerLng < -180 || passengerLng > 180) {
            console.error('Coordinates out of valid range:', {
                driver: [driverLat, driverLng],
                passenger: [passengerLat, passengerLng]
            });
            return;
        }

        // Additional validation: check if coordinates are reasonable
        if (!areReasonableCoordinates(passengerLat, passengerLng)) {
            console.error('Passenger coordinates seem invalid/unreasonable:', {
                passenger: [passengerLat, passengerLng],
                pickupAddress: pickupAddress
            });
            // Don't return - still try to draw, but log the warning
            console.warn('Drawing route with potentially invalid coordinates');
        }

        console.log('Drawing route:', {
            driver: [driverLat, driverLng],
            passenger: [passengerLat, passengerLng],
            address: pickupAddress
        });

        // Clear existing route and markers
        clearRoute();

        // Create passenger pickup marker with correct [lat, lng] order
        const passengerIcon = L.divIcon({
            className: 'passenger-icon-div',
            html: '<div class="passenger-marker-icon"><i class="fas fa-map-marker-alt"></i></div>',
            iconSize: [50, 50],
            iconAnchor: [25, 50]
        });

        passengerMarker = L.marker([passengerLat, passengerLng], { icon: passengerIcon }).addTo(map);
        
        // Add popup to passenger marker
        passengerMarker.bindPopup(`<b>Pickup Location</b><br>${pickupAddress || 'Passenger Location'}`).openPopup();

        // Draw route polyline with smooth animation (using validated coordinates)
        const routePoints = [[driverLat, driverLng], [passengerLat, passengerLng]];
        routePolyline = L.polyline(routePoints, {
            color: '#00A59E',
            weight: 5,
            opacity: 0.7,
            dashArray: '10, 10'
        }).addTo(map);

        // Calculate distance and ETA
        const distance = calculateDistance(driverLat, driverLng, passengerLat, passengerLng);
        const eta = Math.ceil(distance / 0.5); // Assuming average speed of 30 km/h (0.5 km/min)

        // Fit map to show both locations with padding
        if (driverMarker && passengerMarker) {
            const group = new L.featureGroup([driverMarker, passengerMarker]);
            map.fitBounds(group.getBounds().pad(0.2), {
                animate: true,
                duration: 1.0
            });
        }

        // Show route info card
        showRouteInfo(distance, eta);

        console.log('Route drawn successfully:', {
            driver: [driverLat, driverLng],
            passenger: [passengerLat, passengerLng],
            distance: distance.toFixed(2) + ' km',
            eta: eta + ' min'
        });
    }


    // Show route info card on map
    function showRouteInfo(distance, eta) {
        // Remove existing info card if any
        if (routeInfoCard) {
            map.removeControl(routeInfoCard);
        }

        // Create custom control
        const RouteInfoControl = L.Control.extend({
            onAdd: function(map) {
                const div = L.DomUtil.create('div', 'route-info-card');
                div.innerHTML = `
                    <div style="background: white; padding: 15px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); min-width: 200px;">
                        <div style="font-size: 14px; color: #6b7280; margin-bottom: 8px;">Distance to Pickup</div>
                        <div style="font-size: 24px; font-weight: 700; color: #00A59E; margin-bottom: 15px;">${distance.toFixed(1)} km</div>
                        <div style="font-size: 14px; color: #6b7280; margin-bottom: 8px;">Estimated Time</div>
                        <div style="font-size: 20px; font-weight: 600; color: #1f2937;">${eta} min</div>
      </div>
                `;
                return div;
            }
        });

        routeInfoCard = new RouteInfoControl({ position: 'topright' });
        routeInfoCard.addTo(map);
    }

    // Clear route and passenger marker
    function clearRoute() {
        if (passengerMarker) {
            map.removeLayer(passengerMarker);
            passengerMarker = null;
        }
        if (dropoffMarker) {
            map.removeLayer(dropoffMarker);
            dropoffMarker = null;
        }
        if (routePolyline) {
            map.removeLayer(routePolyline);
            routePolyline = null;
        }
        if (routeControl) {
            map.removeControl(routeControl);
            routeControl = null;
        }
        if (routeInfoCard) {
            map.removeControl(routeInfoCard);
            routeInfoCard = null;
        }
    }

    // Helper function to replace Start Ride button with End Ride button
    function replaceStartRideButton() {
        const container = document.getElementById('driver-arrived-button-container');
        if (container) {
            container.innerHTML = `
                <button id="end-ride-btn" class="driver-arrived-btn" style="background: linear-gradient(135deg, #dc2626, #ef4444);">
                    <i class="fas fa-stop"></i>
                    <span>End Ride</span>
                </button>
            `;
            
            // Add event listener to the new End Ride button
            const endRideBtn = document.getElementById('end-ride-btn');
            if (endRideBtn) {
                endRideBtn.addEventListener('click', handleEndRide);
            }
        }
    }

    // Draw route from pickup to dropoff using Leaflet Routing Machine
    function drawRideRoute(pickupCoords, dropoffCoords, pickupAddress, dropoffAddress) {
        if (!map) {
            console.error('Map not initialized');
            return;
        }

        // Validate coordinates (should already be validated, but double-check)
        if (!pickupCoords || !dropoffCoords || 
            !Array.isArray(pickupCoords) || !Array.isArray(dropoffCoords) ||
            pickupCoords.length !== 2 || dropoffCoords.length !== 2) {
            console.error('Invalid coordinates for route drawing:', { pickupCoords, dropoffCoords });
            return;
        }

        const pickupLat = parseFloat(pickupCoords[0]);
        const pickupLng = parseFloat(pickupCoords[1]);
        const dropoffLat = parseFloat(dropoffCoords[0]);
        const dropoffLng = parseFloat(dropoffCoords[1]);

        if (isNaN(pickupLat) || isNaN(pickupLng) || isNaN(dropoffLat) || isNaN(dropoffLng)) {
            console.error('Invalid coordinate values:', { pickupCoords, dropoffCoords });
            return;
        }

        // Final validation - ensure coordinates are reasonable
        if (!areReasonableCoordinates(pickupLat, pickupLng) || 
            !areReasonableCoordinates(dropoffLat, dropoffLng)) {
            console.error('Coordinates out of reasonable bounds:', {
                pickup: [pickupLat, pickupLng],
                dropoff: [dropoffLat, dropoffLng]
            });
            return;
        }

        console.log('Drawing ride route with validated coordinates:', {
            pickup: [pickupLat, pickupLng],
            dropoff: [dropoffLat, dropoffLng]
        });

        // Clear existing route
        clearRoute();

        // Create pickup marker (green)
        const pickupIcon = L.divIcon({
            className: 'passenger-icon-div',
            html: '<div style="background: #10b981; width: 40px; height: 40px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 4px solid white; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4); display: flex; align-items: center; justify-content: center;"><i class="fas fa-map-marker-alt" style="transform: rotate(45deg); color: white; font-size: 18px;"></i></div>',
            iconSize: [40, 40],
            iconAnchor: [20, 40]
        });
        passengerMarker = L.marker([pickupLat, pickupLng], { icon: pickupIcon }).addTo(map);
        passengerMarker.bindPopup(`<b>Pickup Location</b><br>${pickupAddress || 'Pickup'}`).openPopup();

        // Create dropoff marker (red)
        const dropoffIcon = L.divIcon({
            className: 'passenger-icon-div',
            html: '<div style="background: #dc2626; width: 40px; height: 40px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 4px solid white; box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4); display: flex; align-items: center; justify-content: center;"><i class="fas fa-flag-checkered" style="transform: rotate(45deg); color: white; font-size: 18px;"></i></div>',
            iconSize: [40, 40],
            iconAnchor: [20, 40]
        });
        dropoffMarker = L.marker([dropoffLat, dropoffLng], { icon: dropoffIcon }).addTo(map);
        dropoffMarker.bindPopup(`<b>Dropoff Location</b><br>${dropoffAddress || 'Dropoff'}`);

        // Create route using Leaflet Routing Machine with direct coordinates
        const pickupLatLng = L.latLng(pickupLat, pickupLng);
        const dropoffLatLng = L.latLng(dropoffLat, dropoffLng);

        // Calculate distance and ETA using Haversine formula (fallback if routing fails)
        const distance = calculateDistance(pickupLat, pickupLng, dropoffLat, dropoffLng);
        const estimatedETA = Math.ceil(distance / 0.5); // Assuming average speed of 30 km/h (0.5 km/min)

        try {
            routeControl = L.Routing.control({
                waypoints: [pickupLatLng, dropoffLatLng],
                router: L.Routing.osrmv1({
                    serviceUrl: 'https://router.project-osrm.org/route/v1'
                }),
                addWaypoints: false,
                draggableWaypoints: false,
                fitSelectedRoutes: true,
                show: false, // Hide the default control panel
                lineOptions: {
                    styles: [
                        { color: '#00A59E', opacity: 0.9, weight: 6 },
                        { color: '#0EB9D3', opacity: 0.7, weight: 2 }
                    ]
                },
                createMarker: function() { return null; } // Don't create default markers
            }).addTo(map);

            // Listen for route found event to update UI
            routeControl.on('routesfound', function(e) {
                const routes = e.routes;
                if (routes && routes.length > 0) {
                    const route = routes[0];
                    const routeDistance = (route.summary.totalDistance / 1000).toFixed(1); // Convert to km
                    const routeDuration = Math.ceil(route.summary.totalTime / 60); // Convert to minutes

                    // Update or show route info card with actual route data
                    showRideRouteInfo(parseFloat(routeDistance), routeDuration);
                }
            });

            // Handle routing errors gracefully - use fallback distance/ETA
            routeControl.on('routingerror', function(e) {
                console.warn('Routing API error, using fallback distance/ETA:', e);
                showRideRouteInfo(distance, estimatedETA);
            });
        } catch (error) {
            console.error('Error creating route control, using fallback:', error);
            // If routing fails, draw a simple straight line and use calculated distance
            routePolyline = L.polyline([[pickupLat, pickupLng], [dropoffLat, dropoffLng]], {
                color: '#00A59E',
                weight: 5,
                opacity: 0.7,
                dashArray: '10, 10'
            }).addTo(map);
            showRideRouteInfo(distance, estimatedETA);
        }

        // Fit map to show all markers (pickup, dropoff, and driver if available)
        const markers = [passengerMarker, dropoffMarker];
        if (driverMarker) {
            markers.push(driverMarker);
        }
        const group = new L.featureGroup(markers);
        map.fitBounds(group.getBounds().pad(0.2), {
            animate: true,
            duration: 1.0
        });
    }

    // Show ride route info card
    function showRideRouteInfo(distance, duration) {
        // Remove existing info card if any
        if (routeInfoCard) {
            map.removeControl(routeInfoCard);
        }

        // Create custom control
        const RouteInfoControl = L.Control.extend({
            onAdd: function(map) {
                const div = L.DomUtil.create('div', 'route-info-card');
                div.innerHTML = `
                    <div style="background: white; padding: 15px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); min-width: 200px;">
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px; text-transform: uppercase; font-weight: 600;">Route Distance</div>
                        <div style="font-size: 24px; font-weight: 700; color: #00A59E; margin-bottom: 15px;">${distance} km</div>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px; text-transform: uppercase; font-weight: 600;">Estimated Time</div>
                        <div style="font-size: 20px; font-weight: 600; color: #1f2937;">${duration} min</div>
                    </div>
                `;
                return div;
            }
        });

        routeInfoCard = new RouteInfoControl({ position: 'topright' });
        routeInfoCard.addTo(map);
    }

    // Start enhanced location tracking during active ride
    function startRideTracking() {
        if (!navigator.geolocation || isRideActive) {
            return;
        }

        isRideActive = true;

        const options = {
            enableHighAccuracy: true,
            timeout: 3000,
            maximumAge: 0
        };

        // Start a separate watch for ride tracking with smooth following
        rideTrackingWatchId = navigator.geolocation.watchPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;

                currentLat = lat;
                currentLng = lng;

                // Update driver marker position
                if (driverMarker) {
                    driverMarker.setLatLng([lat, lng]);
                }

                // Smoothly pan map to follow driver
                if (map) {
                    map.setView([lat, lng], map.getZoom(), {
                        animate: true,
                        duration: 0.5,
                        easeLinearity: 0.25
                    });
                }
            },
            (error) => {
                console.error('Ride tracking error:', error);
            },
            options
        );
    }

    // Stop enhanced ride tracking
    function stopRideTracking() {
        if (rideTrackingWatchId !== null) {
            navigator.geolocation.clearWatch(rideTrackingWatchId);
            rideTrackingWatchId = null;
        }
        isRideActive = false;
    }

    // Simulate ride request (for testing - remove in production)
    function simulateRideRequest() {
        const mockRideData = {
            passengerName: 'John Doe',
            rating: '4.8',
            pickup: 'Mumbai Airport, Terminal 2',
            dropoff: 'Gateway of India, Mumbai',
            fare: '350',
            serviceType: 'Premium',
            id: 123
        };
        showRideRequest(mockRideData);
    }

    // Check for real ride requests (polling or WebSocket)
    function checkForRideRequests() {
        // Only check if popup is not currently showing
        const overlay = document.getElementById('ride-request-overlay');
        if (overlay.classList.contains('show')) {
            return; // Don't check for new requests while one is active
        }

        // Poll for new ride requests
        fetch("{% url 'driver:api_assigned_requests' %}")
            .then(response => response.json())
            .then(data => {
                if (data.assigned_request_ids && data.assigned_request_ids.length > 0) {
                    // Find new request IDs that we haven't processed
                    const newRequestIds = data.assigned_request_ids.filter(id => !processedRequestIds.has(id));
                    
                    if (newRequestIds.length > 0) {
                        // Fetch details for the first new request
                        const requestId = newRequestIds[0];
                        fetchRideRequestDetails(requestId);
                    }
                }
            })
            .catch(error => console.error('Error checking ride requests:', error));
    }

    // Fetch detailed ride request information
    function fetchRideRequestDetails(requestId) {
        const url = "{% url 'driver:api_ride_request_details' 0 %}".replace('0', requestId);
        console.log('Fetching ride request details from:', url);
        
        fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
            },
            credentials: 'same-origin' // Include cookies for authentication
        })
            .then(response => {
                console.log('Ride request details response:', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok
                });
                
                if (!response.ok) {
                    return response.text().then(text => {
                        console.error('Error response body:', text);
                        throw new Error(`Failed to fetch ride request details: ${response.status} - ${text}`);
                    });
                }
                return response.json();
            })
            .then(rideData => {
                console.log('Ride request details received:', {
                    id: rideData.id,
                    pickupLat: rideData.pickupLat,
                    pickupLng: rideData.pickupLng,
                    pickup: rideData.pickup
                });
                
                // Validate coordinates in response
                if (rideData.pickupLat === null || rideData.pickupLat === undefined ||
                    rideData.pickupLng === null || rideData.pickupLng === undefined) {
                    console.error('Missing coordinates in API response:', rideData);
                }
                
                // Show the popup with ride request details
                showRideRequest(rideData);
            })
            .catch(error => {
                console.error('Error fetching ride request details:', error);
                showToast('Failed to load ride request details', 'error');
            });
    }

    // Show Driver Arrived button
    function showDriverArrivedButton() {
        const container = document.getElementById('driver-arrived-button-container');
        if (container) {
            container.style.display = 'block';
        }
    }

    // Hide Driver Arrived button
    function hideDriverArrivedButton() {
        const container = document.getElementById('driver-arrived-button-container');
        if (container) {
            container.style.display = 'none';
        }
    }

    // Render PIN verification + Start Ride controls
    function renderPinVerificationCard() {
        const container = document.getElementById('driver-arrived-button-container');
        if (!container) return;

        container.style.display = 'block';
        container.innerHTML = `
            <div class="pin-card" style="display:flex; flex-direction:column; gap:10px; width:100%;">
                <label style="font-weight:700; color:#1f2937; font-size:14px;">Enter passenger PIN to start ride</label>
                <div style="display:flex; gap:8px; align-items:center;">
                    <input id="ride-pin-input" type="text" maxlength="4" pattern="\\d{4}" inputmode="numeric" placeholder="4-digit PIN" style="flex:1; padding:10px 12px; border:1px solid #e5e7eb; border-radius:10px; font-size:16px; letter-spacing:4px; text-align:center; font-weight:700;">
                    <button id="verify-pin-btn" class="driver-arrived-btn" style="background: linear-gradient(135deg, #0ea5e9, #0284c7); padding:10px 14px; min-width:120px;">
                        <i class="fas fa-check"></i>
                        <span>Verify PIN</span>
                    </button>
                </div>
                <p id="pin-helper-text" style="color:#6b7280; font-size:12px;">Ask the passenger for the ride PIN shown on their phone.</p>
                <p id="pin-error-text" style="color:#dc2626; font-size:12px; display:none;"></p>
                <button id="start-ride-btn" class="driver-arrived-btn" style="background: linear-gradient(135deg, #9333ea, #a855f7);" disabled>
                    <i class="fas fa-lock"></i>
                    <span>Start Ride</span>
                </button>
            </div>
        `;

        // Add event listeners
        const startRideBtn = document.getElementById('start-ride-btn');
        if (startRideBtn) {
            startRideBtn.addEventListener('click', handleStartRide);
        }

        const verifyPinBtn = document.getElementById('verify-pin-btn');
        if (verifyPinBtn) {
            verifyPinBtn.addEventListener('click', verifyRidePin);
        }

        ridePinVerified = false;
        ridePinLockedUntil = null;
    }

    // Update status card
    function updateStatusCard(statusText, subMessage) {
        const statusMessage = document.getElementById('status-message');
        const statusSubmessage = document.getElementById('status-submessage');
        if (statusMessage) {
            statusMessage.innerHTML = `<span class="status-indicator"></span>${statusText}`;
        }
        if (statusSubmessage) {
            statusSubmessage.textContent = subMessage;
        }
    }

    // Handle successful ride acceptance
    function handleAcceptSuccess(rideRequestId) {
        console.log('Ride accepted successfully (redirect)');
        showToast('Ride accepted successfully!', 'success');
        showDriverArrivedButton();
        updateStatusCard('Ride Accepted', 'Heading to pickup location');
        
        // Try to get booking_id by fetching the ride request details
        // The booking should be linked to the ride_request after acceptance
        setTimeout(() => {
            getBookingIdFromRideRequest(rideRequestId);
        }, 1000);
    }

    // Get booking ID from ride request ID
    async function getBookingIdFromRideRequest(rideRequestId) {
        try {
            const response = await fetch("{% url 'driver:api_ride_request_details' 0 %}".replace('0', rideRequestId));
            if (response.ok) {
                const data = await response.json();
                if (data.booking_id) {
                    currentBookingId = data.booking_id;
                    console.log('Booking ID retrieved:', currentBookingId);
                } else {
                    console.warn('Booking ID not yet available in ride request');
                }
            }
        } catch (error) {
            console.error('Error getting booking ID:', error);
        }
    }

    // Handle Driver Arrived button click
    async function handleDriverArrived() {
        // If we don't have booking_id, try to get it from the current ride request
        if (!currentBookingId && currentRideRequest) {
            try {
                const response = await fetch("{% url 'driver:api_ride_request_details' 0 %}".replace('0', currentRideRequest.id));
                if (response.ok) {
                    const data = await response.json();
                    if (data.booking_id) {
                        currentBookingId = data.booking_id;
                        console.log('Booking ID retrieved:', currentBookingId);
                        // Continue with the arrival notification
                    } else {
                        showToast('Booking not found. Please refresh the page.', 'error');
                        return;
                    }
                } else {
                    showToast('Unable to get booking information', 'error');
                    return;
                }
            } catch (error) {
                console.error('Error fetching booking ID:', error);
                showToast('Unable to get booking information', 'error');
                return;
            }
        }
        
        if (!currentBookingId) {
            console.error('No active booking ID');
            showToast('No active booking found. Please refresh the page.', 'error');
            return;
        }

        const btn = document.getElementById('driver-arrived-btn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Notifying...</span>';
        }

        // Get CSRF token
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        const csrfToken = getCookie('csrftoken') || '{{ csrf_token }}';
        const arrivedUrl = "{% url 'driver:arrived_ride' 0 %}".replace('0', currentBookingId);

        fetch(arrivedUrl, {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: `csrfmiddlewaretoken=${encodeURIComponent(csrfToken)}`,
            credentials: 'same-origin',
            mode: 'same-origin'
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Driver arrived notification sent');
                showToast(data.message || 'Passenger notified: Driver has arrived!', 'success');
                updateStatusCard('Driver Arrived', 'Waiting for passenger');
                
                renderPinVerificationCard();
            } else {
                throw new Error(data.error || 'Failed to send arrival notification');
            }
        })
        .catch(error => {
            console.error('Error sending arrival notification:', error);
            showToast(error.message || 'Failed to send arrival notification', 'error');
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-map-marker-alt"></i><span>Driver Arrived</span>';
            }
        });
    }

    async function verifyRidePin() {
        if (!currentBookingId) {
            showToast('No active booking found. Please refresh the page.', 'error');
            return;
        }

        const pinInput = document.getElementById('ride-pin-input');
        const errorText = document.getElementById('pin-error-text');
        const startRideBtn = document.getElementById('start-ride-btn');
        const verifyBtn = document.getElementById('verify-pin-btn');
        if (!pinInput) return;

        const pinValue = pinInput.value.trim();
        if (!/^[0-9]{4}$/.test(pinValue)) {
            errorText.style.display = 'block';
            errorText.textContent = 'Enter a valid 4-digit PIN.';
            return;
        }

        errorText.style.display = 'none';
        if (verifyBtn) {
            verifyBtn.disabled = true;
            verifyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Verifying...</span>';
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        const csrfToken = getCookie('csrftoken') || '{{ csrf_token }}';
        const verifyUrl = "{% url 'driver:verify_ride_pin' 0 %}".replace('0', currentBookingId);

        fetch(verifyUrl, {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: `pin=${encodeURIComponent(pinValue)}&csrfmiddlewaretoken=${encodeURIComponent(csrfToken)}`,
            credentials: 'same-origin',
            mode: 'same-origin'
        })
        .then(resp => resp.json().then(data => ({ status: resp.status, body: data })))
        .then(({ status, body }) => {
            if (body.success) {
                ridePinVerified = true;
                if (startRideBtn) {
                    startRideBtn.disabled = false;
                    startRideBtn.innerHTML = '<i class="fas fa-play"></i><span>Start Ride</span>';
                }
                if (pinInput) {
                    pinInput.disabled = true;
                }
                errorText.style.display = 'none';
                showToast(body.message || 'PIN verified', 'success');
            } else {
                ridePinVerified = false;
                if (body.locked) {
                    ridePinLockedUntil = body.locked_until;
                    if (startRideBtn) {
                        startRideBtn.disabled = true;
                    }
                }
                errorText.style.display = 'block';
                errorText.textContent = body.error || 'Invalid PIN.';
            }
        })
        .catch(err => {
            console.error('PIN verify error', err);
            errorText.style.display = 'block';
            errorText.textContent = 'Unable to verify PIN. Please try again.';
        })
        .finally(() => {
            if (verifyBtn) {
                verifyBtn.disabled = false;
                verifyBtn.innerHTML = '<i class="fas fa-check"></i><span>Verify PIN</span>';
            }
        });
    }

    // Handle Start Ride button click
    async function handleStartRide() {
        if (!currentBookingId) {
            showToast('No active booking found. Please refresh the page.', 'error');
            return;
        }

        if (!ridePinVerified) {
            showToast('Verify the passenger PIN before starting the ride.', 'error');
            return;
        }

        const btn = document.getElementById('start-ride-btn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Starting...</span>';
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        const csrfToken = getCookie('csrftoken') || '{{ csrf_token }}';
        const startRideUrl = "{% url 'driver:start_ride' 0 %}".replace('0', currentBookingId);

        fetch(startRideUrl, {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: `csrfmiddlewaretoken=${encodeURIComponent(csrfToken)}`,
            credentials: 'same-origin',
            mode: 'same-origin'
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Ride started - API response:', data);
                showToast(data.message || 'Ride started! Route displayed on map.', 'success');
                updateStatusCard('Ride in Progress', 'Trip is ongoing');
                
                // Function to get coordinates with multiple fallbacks
                async function getRideCoordinates() {
                    let pickupCoords = null;
                    let dropoffCoords = null;
                    let pickupAddress = 'Pickup Location';
                    let dropoffAddress = 'Dropoff Location';
                    
                    // Log current stored coordinates
                    console.log('Checking stored coordinates:', {
                        storedPickupCoords: storedPickupCoords,
                        storedDropoffCoords: storedDropoffCoords,
                        storedPickupAddress: storedPickupAddress,
                        storedDropoffAddress: storedDropoffAddress
                    });
                    
                    // Step 1: Try stored coordinates (from ride acceptance)
                    if (storedPickupCoords && storedDropoffCoords && 
                        Array.isArray(storedPickupCoords) && Array.isArray(storedDropoffCoords) &&
                        storedPickupCoords.length === 2 && storedDropoffCoords.length === 2) {
                        
                        const storedPickupLat = parseFloat(storedPickupCoords[0]);
                        const storedPickupLng = parseFloat(storedPickupCoords[1]);
                        const storedDropoffLat = parseFloat(storedDropoffCoords[0]);
                        const storedDropoffLng = parseFloat(storedDropoffCoords[1]);
                        
                        if (!isNaN(storedPickupLat) && !isNaN(storedPickupLng) &&
                            !isNaN(storedDropoffLat) && !isNaN(storedDropoffLng) &&
                            areReasonableCoordinates(storedPickupLat, storedPickupLng) &&
                            areReasonableCoordinates(storedDropoffLat, storedDropoffLng)) {
                            
                            pickupCoords = [storedPickupLat, storedPickupLng];
                            dropoffCoords = [storedDropoffLat, storedDropoffLng];
                            pickupAddress = storedPickupAddress || pickupAddress;
                            dropoffAddress = storedDropoffAddress || dropoffAddress;
                            
                            console.log('✅ Using stored coordinates:', {
                                pickup: pickupCoords,
                                dropoff: dropoffCoords
                            });
                            return { pickupCoords, dropoffCoords, pickupAddress, dropoffAddress };
                        } else {
                            console.warn('Stored coordinates failed validation:', {
                                pickup: [storedPickupLat, storedPickupLng],
                                dropoff: [storedDropoffLat, storedDropoffLng]
                            });
                        }
                    }
                    
                    // Step 2: Try coordinates from API response
                    if (data.pickup_latitude && data.pickup_longitude && 
                        data.drop_latitude && data.drop_longitude) {
                        
                        const apiPickupLat = parseFloat(data.pickup_latitude);
                        const apiPickupLng = parseFloat(data.pickup_longitude);
                        const apiDropoffLat = parseFloat(data.drop_latitude);
                        const apiDropoffLng = parseFloat(data.drop_longitude);
                        
                        console.log('Checking API response coordinates:', {
                            pickup: [apiPickupLat, apiPickupLng],
                            dropoff: [apiDropoffLat, apiDropoffLng]
                        });
                        
                        if (!isNaN(apiPickupLat) && !isNaN(apiPickupLng) && 
                            !isNaN(apiDropoffLat) && !isNaN(apiDropoffLng) &&
                            areReasonableCoordinates(apiPickupLat, apiPickupLng) &&
                            areReasonableCoordinates(apiDropoffLat, apiDropoffLng)) {
                            
                            pickupCoords = [apiPickupLat, apiPickupLng];
                            dropoffCoords = [apiDropoffLat, apiDropoffLng];
                            pickupAddress = data.pickup_location || pickupAddress;
                            dropoffAddress = data.dropoff_location || dropoffAddress;
                            
                            console.log('✅ Using coordinates from API response:', {
                                pickup: pickupCoords,
                                dropoff: dropoffCoords
                            });
                            return { pickupCoords, dropoffCoords, pickupAddress, dropoffAddress };
                        } else {
                            console.warn('API response coordinates failed validation');
                        }
                    }
                    
                    // Step 3: Fetch from booking API endpoint
                    console.log('Fetching coordinates from booking API...');
                    return fetch("{% url 'driver:api_booking_details' 0 %}".replace('0', currentBookingId.toString()), {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                        },
                        credentials: 'same-origin'
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Booking API returned ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(async bookingData => {
                        console.log('Booking API response:', bookingData);
                        
                        // Extract addresses from API response
                        const apiPickupAddress = bookingData.pickup_location || null;
                        const apiDropoffAddress = bookingData.dropoff_location || null;
                        
                        // Try to get coordinates directly from API response
                        let bookingPickupLat = null;
                        let bookingPickupLng = null;
                        let bookingDropoffLat = null;
                        let bookingDropoffLng = null;
                        
                        if (bookingData.pickup_latitude && bookingData.pickup_longitude) {
                            bookingPickupLat = parseFloat(bookingData.pickup_latitude);
                            bookingPickupLng = parseFloat(bookingData.pickup_longitude);
                        }
                        
                        if (bookingData.drop_latitude && bookingData.drop_longitude) {
                            bookingDropoffLat = parseFloat(bookingData.drop_latitude);
                            bookingDropoffLng = parseFloat(bookingData.drop_longitude);
                        }
                        
                        console.log('Booking API - Direct coordinates:', {
                            pickup: bookingPickupLat && bookingPickupLng ? [bookingPickupLat, bookingPickupLng] : 'Not available',
                            dropoff: bookingDropoffLat && bookingDropoffLng ? [bookingDropoffLat, bookingDropoffLng] : 'Not available',
                            pickupAddress: apiPickupAddress,
                            dropoffAddress: apiDropoffAddress
                        });
                        
                        // If coordinates are missing but addresses are available, geocode them
                        if ((!bookingPickupLat || !bookingPickupLng) && apiPickupAddress) {
                            console.log('Geocoding pickup address:', apiPickupAddress);
                            try {
                                const geocodedPickup = await geocodeAddress(apiPickupAddress);
                                bookingPickupLat = geocodedPickup.lat;
                                bookingPickupLng = geocodedPickup.lng;
                                console.log('✅ Geocoded pickup coordinates:', [bookingPickupLat, bookingPickupLng]);
                            } catch (error) {
                                console.error('Failed to geocode pickup address:', error);
                            }
                        }
                        
                        if ((!bookingDropoffLat || !bookingDropoffLng) && apiDropoffAddress) {
                            console.log('Geocoding dropoff address:', apiDropoffAddress);
                            try {
                                const geocodedDropoff = await geocodeAddress(apiDropoffAddress);
                                bookingDropoffLat = geocodedDropoff.lat;
                                bookingDropoffLng = geocodedDropoff.lng;
                                console.log('✅ Geocoded dropoff coordinates:', [bookingDropoffLat, bookingDropoffLng]);
                            } catch (error) {
                                console.error('Failed to geocode dropoff address:', error);
                            }
                        }
                        
                        // Validate the coordinates (whether from API or geocoded)
                        if (bookingPickupLat && bookingPickupLng && bookingDropoffLat && bookingDropoffLng &&
                            !isNaN(bookingPickupLat) && !isNaN(bookingPickupLng) && 
                            !isNaN(bookingDropoffLat) && !isNaN(bookingDropoffLng) &&
                            areReasonableCoordinates(bookingPickupLat, bookingPickupLng) &&
                            areReasonableCoordinates(bookingDropoffLat, bookingDropoffLng)) {
                            
                            pickupCoords = [bookingPickupLat, bookingPickupLng];
                            dropoffCoords = [bookingDropoffLat, bookingDropoffLng];
                            pickupAddress = apiPickupAddress || pickupAddress;
                            dropoffAddress = apiDropoffAddress || dropoffAddress;
                            
                            // Update stored coordinates for future use
                            storedPickupCoords = pickupCoords;
                            storedDropoffCoords = dropoffCoords;
                            storedPickupAddress = pickupAddress;
                            storedDropoffAddress = dropoffAddress;
                            
                            console.log('✅ Using coordinates from booking API (direct or geocoded):', {
                                pickup: pickupCoords,
                                dropoff: dropoffCoords,
                                pickupAddress: pickupAddress,
                                dropoffAddress: dropoffAddress
                            });
                            
                            return { pickupCoords, dropoffCoords, pickupAddress, dropoffAddress };
                        } else {
                            console.error('Booking API coordinates validation failed:', {
                                pickup: bookingPickupLat && bookingPickupLng ? [bookingPickupLat, bookingPickupLng] : 'Missing',
                                dropoff: bookingDropoffLat && bookingDropoffLng ? [bookingDropoffLat, bookingDropoffLng] : 'Missing'
                            });
                            throw new Error('No valid coordinates found in booking API response (after geocoding attempt)');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching from booking API:', error);
                        throw error;
                    });
                }
                
                // Get coordinates and draw route
                getRideCoordinates()
                    .then(routeData => {
                        if (routeData && routeData.pickupCoords && routeData.dropoffCoords) {
                            const pickupLat = routeData.pickupCoords[0];
                            const pickupLng = routeData.pickupCoords[1];
                            const dropoffLat = routeData.dropoffCoords[0];
                            const dropoffLng = routeData.dropoffCoords[1];
                            
                            console.log('✅ Final coordinates for route drawing:');
                            console.log('Pickup:', pickupLat, pickupLng, '- Address:', routeData.pickupAddress);
                            console.log('Dropoff:', dropoffLat, dropoffLng, '- Address:', routeData.dropoffAddress);
                            
                            // Final validation before drawing
                            if (!areReasonableCoordinates(pickupLat, pickupLng) || 
                                !areReasonableCoordinates(dropoffLat, dropoffLng)) {
                                throw new Error('Final coordinates failed validation');
                            }
                            
                            // Draw the route immediately with known coordinates
                            drawRideRoute(
                                routeData.pickupCoords,
                                routeData.dropoffCoords,
                                routeData.pickupAddress,
                                routeData.dropoffAddress
                            );
                            
                            // Start enhanced tracking
                            startRideTracking();
                        } else {
                            throw new Error('No valid coordinates available');
                        }
                    })
                    .catch(error => {
                        console.error('Failed to get coordinates:', error);
                        showToast('Unable to display route. Coordinates missing.', 'error');
                    })
                    .finally(() => {
                        // Replace "Start Ride" button with "End Ride" button (always)
                        replaceStartRideButton();
                    });
            } else {
                throw new Error(data.error || 'Failed to start ride');
            }
        })
        .catch(error => {
            console.error('Error starting ride:', error);
            showToast(error.message || 'Failed to start ride', 'error');
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-play"></i><span>Start Ride</span>';
            }
        });
    }

    // Handle End Ride button click
    async function handleEndRide() {
        if (!currentBookingId) {
            showToast('No active booking found. Please refresh the page.', 'error');
            return;
        }

        const btn = document.getElementById('end-ride-btn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Ending...</span>';
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Stop enhanced ride tracking
        stopRideTracking();
        
        // Clear route from map
        clearRoute();
        
        // Clear stored coordinates (for next ride)
        storedPickupCoords = null;
        storedDropoffCoords = null;
        storedPickupAddress = null;
        storedDropoffAddress = null;

        const csrfToken = getCookie('csrftoken') || '{{ csrf_token }}';
        const endRideUrl = "{% url 'driver:end_ride' 0 %}".replace('0', currentBookingId);

        fetch(endRideUrl, {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: `csrfmiddlewaretoken=${encodeURIComponent(csrfToken)}`,
            credentials: 'same-origin',
            mode: 'same-origin'
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Ride ended');
                showToast(data.message || 'Ride completed! Payment recorded.', 'success');
                updateStatusCard('Ride Completed', 'Trip finished successfully');
                
                // Reset current booking ID
                currentBookingId = null;
                
                // Replace "End Ride" button with completed indicator
                const container = document.getElementById('driver-arrived-button-container');
                if (container) {
                    container.innerHTML = `
                        <div class="driver-arrived-btn" style="background: linear-gradient(135deg, #10b981, #059669); cursor: default;">
                            <i class="fas fa-check-circle"></i>
                            <span>Ride Completed</span>
                        </div>
                    `;
                }
                
                // Show ride completed notification popup
                showRideCompletedPopup(data);
            } else {
                throw new Error(data.error || 'Failed to end ride');
            }
        })
        .catch(error => {
            console.error('Error ending ride:', error);
            showToast(error.message || 'Failed to end ride', 'error');
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-stop"></i><span>End Ride</span>';
            }
        });
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
        initMap();

        // Check for ride requests every 5 seconds (if driver is online)
        const availabilityToggle = document.getElementById('availability-toggle');
        if (availabilityToggle && availabilityToggle.checked) {
            setInterval(checkForRideRequests, 5000);
        }

        // Add event listener for Driver Arrived button
        const driverArrivedBtn = document.getElementById('driver-arrived-btn');
        if (driverArrivedBtn) {
            driverArrivedBtn.addEventListener('click', handleDriverArrived);
        }

        // Rehydrate UI if there's an active booking from server (page reload scenario)
        if (serverActiveBookingId) {
            currentBookingId = serverActiveBookingId;
            if (serverActiveBookingStatus === 'Confirmed') {
                showDriverArrivedButton();
                updateStatusCard('Ride Accepted', 'Heading to pickup location');
            } else if (serverActiveBookingStatus === 'Arrived') {
                renderPinVerificationCard();
                updateStatusCard('Driver Arrived', 'Waiting for passenger');
            } else if (serverActiveBookingStatus === 'Ongoing') {
                const container = document.getElementById('driver-arrived-button-container');
                if (container) {
                    container.style.display = 'block';
                }
                replaceStartRideButton();
                updateStatusCard('Ride in Progress', 'Trip is ongoing');
            }
        }

        // For testing: Add a button to simulate ride request (remove in production)
        // Uncomment the line below to test the notification
        // setTimeout(simulateRideRequest, 5000);
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (watchId !== null) {
            navigator.geolocation.clearWatch(watchId);
        }
        if (rideTrackingWatchId !== null) {
            navigator.geolocation.clearWatch(rideTrackingWatchId);
        }
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }
        // Stop ride tracking
        stopRideTracking();
    });
</script>
</body>
</html>
