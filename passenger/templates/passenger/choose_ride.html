{% load static %}
{% load custom_filters %}

{% block extra_css %}
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
<link rel="stylesheet" href="{% static 'css/responsive.css' %}">
<style>
  /* Ensure the Leaflet map never overflows and respects rounded corners */
  #ride-map {
    height: 320px;
    width: 100%;
  }
  .map-shell {
    overflow: hidden; /* clip any overflowing tiles/controls */
    border-radius: 0.75rem; /* rounded-xl */
  }
  .leaflet-container {
    font: inherit; /* keep consistent typography */
  }
  .leaflet-top, .leaflet-bottom {
    z-index: 10; /* stay under sticky headers if any */
  }
  @media (min-width: 1024px) {
    #ride-map { height: 360px; }
  }
  @media (max-width: 640px) {
    #ride-map { height: 260px; }
  }
}</style>
{% endblock %}

{% block content %}
<section class="bg-gray-50 py-10">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mb-4">
    <a href="{% url 'homepage' %}" class="inline-block text-sm text-teal-600 font-semibold hover:underline hover:text-teal-800 transition">
      ← Back
    </a>
  </div>
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 grid lg:grid-cols-3 gap-8">

    <div class="bg-white shadow-md rounded-2xl p-6">
      <div class="flex justify-center mb-4">
        <div id="ride-type-tabs" class="flex bg-gray-100 rounded-xl p-1 w-full" data-outstation-km="{{ outstation_distance_km }}">
          <button data-type="daily" class="flex-1 py-2 {% if ride_type == 'daily' %}bg-gradient-to-r from-teal-500 to-teal-600 text-white rounded-l-xl font-medium text-sm{% else %}text-gray-600 hover:bg-gray-200 transition font-medium text-sm{% endif %}">Daily Ride</button>
          <button data-type="outstation" class="flex-1 py-2 {% if ride_type == 'outstation' %}bg-gradient-to-r from-teal-500 to-teal-600 text-white font-medium text-sm{% else %}text-gray-600 hover:bg-gray-200 transition font-medium text-sm{% endif %}">Outstation</button>
          <button data-type="rental" class="flex-1 py-2 {% if ride_type == 'rental' %}bg-gradient-to-r from-teal-500 to-teal-600 text-white rounded-r-xl font-medium text-sm{% else %}text-gray-600 hover:bg-gray-200 transition font-medium text-sm rounded-r-xl{% endif %}">Rental</button>
        </div>
      </div>

      <input type="hidden" name="ride_type" value="{{ ride_type }}">
      <input type="hidden" id="pickup_lat" value="{{ pickup_lat|default:'' }}">
      <input type="hidden" id="pickup_lng" value="{{ pickup_lng|default:'' }}">
      <input type="hidden" id="drop_lat" value="{{ drop_lat|default:'' }}">
      <input type="hidden" id="drop_lng" value="{{ drop_lng|default:'' }}">
      <input type="hidden" id="pickup_city" value="{{ pickup_city|default:'' }}">
      <input type="hidden" id="pickup_district" value="{{ pickup_district|default:'' }}">
      <input type="hidden" id="pickup_state" value="{{ pickup_state|default:'' }}">
      <input type="hidden" id="drop_city" value="{{ drop_city|default:'' }}">
      <input type="hidden" id="drop_district" value="{{ drop_district|default:'' }}">
      <input type="hidden" id="drop_state" value="{{ drop_state|default:'' }}">
      <input type="hidden" id="distance_km" value="{{ distance_km|default:'' }}">
      <input type="hidden" id="duration_min" value="{{ duration_min|default:'' }}">
      <div class="mb-4">
        <input type="text" name="pickup" placeholder="Pickup Location" value="{{ pickup }}" class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-teal-500">
      </div>
      <div class="mb-4">
        <input type="text" name="dropoff" placeholder="Dropoff Location" value="{{ dropoff }}" class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-teal-500">
      </div>
      <div id="ride_type_notice" class="{% if ride_type_notice %}text-sm text-amber-800 bg-amber-50 border border-amber-200 rounded-lg px-3 py-2 mb-4{% else %}hidden text-sm text-amber-800 bg-amber-50 border border-amber-200 rounded-lg px-3 py-2 mb-4{% endif %}">{{ ride_type_notice }}</div>

      <div class="grid grid-cols-2 gap-4 mb-4">
        <div>
          <input type="date" name="ride_date" value="{{ ride_date }}" class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-teal-500">
        </div>
        <div>
          <input type="time" name="ride_time" value="{{ ride_time }}" class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-teal-500">
        </div>
      </div>

      {% if ride_type == 'rental' %}
      <div class="mt-4">
        <label for="rental_duration" class="block text-sm font-medium text-gray-700 mb-1">Select Rental Package</label>
        <select name="rental_duration" class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-teal-500">
          {% if rental_options %}
            {% for option in rental_options %}
              <option value="{{ option.id }}" {% if rental_duration == option.id|stringformat:"s" %}selected{% endif %}>
                {{ option.distance_km }} KM / {{ option.time_hours }} Hours
              </option>
            {% endfor %}
          {% else %}
            <option disabled selected>No durations available</option>
          {% endif %}
        </select>
      </div>
      {% endif %}
    </div>

    <div class="lg:col-span-2">
      <div class="bg-white shadow-md rounded-2xl p-6">
        <div class="mb-4">
          <div class="flex items-center justify-between">
            <h3 class="font-semibold text-gray-800">Route Preview</h3>
            <span id="route-distance" class="hidden text-sm bg-teal-50 text-teal-700 px-3 py-1 rounded-full border border-teal-200">Distance: --</span>
          </div>
          <div class="mt-3 map-shell border">
            <div id="ride-map"></div>
          </div>
        </div>
        <div class="space-y-4 mb-6" data-outstation-disallowed="{{ outstation_disallowed_csv }}">
          {% if estimated_fares %}
            {% for fare in estimated_fares %}
              <label class="block">
                <input type="radio" name="selected_service" value="{{ fare.service_id }}" class="peer hidden" required data-service-name="{{ fare.service_name }}">
                <div class="flex items-center p-4 border rounded-xl hover:shadow transition cursor-pointer peer-checked:border-2 peer-checked:border-teal-500 mb-2">
                  <div class="mr-4 flex-shrink-0">
                    {% if fare.icon %}
                      <i class="{{ fare.icon }} text-teal-500 text-2xl"></i>
                    {% else %}
                      <i class="fas fa-car text-teal-500 text-2xl"></i>
                    {% endif %}
                  </div>
                  <div class="flex-1">
                    <p class="font-semibold text-gray-800">{{ fare.service_name }}</p> {# CHANGED THIS LINE #}
                    <p class="text-sm text-gray-500">{{ fare.number_of_seats }} Seater</p>
                  </div>
                  <div class="text-right text-sm text-gray-600">
                    <p class="text-teal-600 font-bold text-lg mt-1">₹{{ fare.estimated_price }}</p>
                    <p class="text-xs text-gray-400">Total Fare</p>
                  </div>
                </div>
              </label>
            {% endfor %}
          {% else %}
            <p class="text-center text-gray-500">No services available.</p>
          {% endif %}
        </div>


        <div>
          <button id="book-ride-btn" class="w-full bg-gradient-to-r from-teal-500 to-teal-600 text-white py-3 rounded-xl font-semibold hover:shadow-lg transition-all disabled:opacity-50" disabled>Book a Ride</button>
        </div>

      </div>
    </div>
  </div>
</section>

<script src="{% static 'passenger/js/ride-rules.js' %}"></script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    const rideRules = window.RideRules || null;
    const tabsContainer = document.getElementById('ride-type-tabs');
    const buttons = tabsContainer.querySelectorAll('button');
    const rideTypeNotice = document.getElementById('ride_type_notice');
    const outstationThresholdKm = tabsContainer && tabsContainer.dataset.outstationKm ? parseFloat(tabsContainer.dataset.outstationKm) : 40;
    const serviceList = document.querySelector('.space-y-4[data-outstation-disallowed]');
    const outstationDisallowed = serviceList && serviceList.dataset.outstationDisallowed
      ? serviceList.dataset.outstationDisallowed.split(',').map(item => item.trim().toLowerCase()).filter(Boolean)
      : ['bike', 'auto'];

    const pickupCity = document.getElementById('pickup_city');
    const pickupDistrict = document.getElementById('pickup_district');
    const pickupState = document.getElementById('pickup_state');
    const dropCity = document.getElementById('drop_city');
    const dropDistrict = document.getElementById('drop_district');
    const dropState = document.getElementById('drop_state');

    function normalizeText(value) {
      return rideRules && rideRules.normalizeText ? rideRules.normalizeText(value) : (value || '').toString().trim().toLowerCase();
    }

    function setNotice(message, tone) {
      if (!rideTypeNotice) return;
      if (!message) {
        rideTypeNotice.textContent = '';
        rideTypeNotice.classList.add('hidden');
        return;
      }
      rideTypeNotice.textContent = message;
      rideTypeNotice.classList.remove('hidden');
      rideTypeNotice.classList.remove('text-amber-800','bg-amber-50','border-amber-200','text-red-800','bg-red-50','border-red-200','text-green-800','bg-green-50','border-green-200');
      if (tone === 'error') {
        rideTypeNotice.classList.add('text-red-800','bg-red-50','border-red-200');
      } else if (tone === 'success') {
        rideTypeNotice.classList.add('text-green-800','bg-green-50','border-green-200');
      } else {
        rideTypeNotice.classList.add('text-amber-800','bg-amber-50','border-amber-200');
      }
    }

    function extractAddressParts(result) {
      if (rideRules && rideRules.extractAddressParts) {
        return rideRules.extractAddressParts(result);
      }
      return { city: '', district: '', state: '' };
    }

    function isDailyAllowed(pickupMeta, dropoffMeta) {
      if (!rideRules || !rideRules.isDailyAllowed) return { allowed: null };
      return rideRules.isDailyAllowed(pickupMeta, dropoffMeta, {});
    }

    function applyDistanceRule(distanceKm) {
      if (!distanceKm || isNaN(distanceKm)) return false;
      const rideTypeInput = document.querySelector('input[name="ride_type"]');
      const selectedRideType = normalizeText(rideTypeInput ? rideTypeInput.value : '');
      if (selectedRideType !== 'daily') return false;
      if (distanceKm >= outstationThresholdKm) {
        setNotice(`Daily Ride is limited to local trips. Distance is ${distanceKm.toFixed(1)} km, switched to Outstation.`, 'error');
        const outstationBtn = document.querySelector('#ride-type-tabs [data-type="outstation"]');
        if (outstationBtn) outstationBtn.click();
        return true;
      }
      return false;
    }

    function geocodeWithAddress(place) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&q=${encodeURIComponent(place)}&limit=1`;
      return fetch(url, { headers: { 'Accept': 'application/json' } })
        .then(r => r.json())
        .then(res => {
          if (Array.isArray(res) && res.length) return res[0];
          throw new Error('No results');
        });
    }

    const rideType = document.querySelector('input[name="ride_type"]').value;
    buttons.forEach(btn => {
      if (btn.getAttribute('data-type') === rideType) {
        btn.classList.add('bg-gradient-to-r', 'from-teal-500', 'to-teal-600', 'text-white');
        btn.classList.remove('text-gray-600', 'hover:bg-gray-200');
        if (btn === buttons[0]) btn.classList.add('rounded-l-xl');
        if (btn === buttons[buttons.length - 1]) btn.classList.add('rounded-r-xl');
      } else {
        btn.classList.remove('bg-gradient-to-r', 'from-teal-500', 'to-teal-600', 'text-white');
        btn.classList.add('text-gray-600', 'hover:bg-gray-200');
        btn.classList.remove('rounded-l-xl', 'rounded-r-xl');
      }
    });

    buttons.forEach(button => {
      button.addEventListener('click', () => {
        buttons.forEach(btn => {
          btn.classList.remove('bg-gradient-to-r', 'from-teal-500', 'to-teal-600', 'text-white');
          btn.classList.add('text-gray-600', 'hover:bg-gray-200');
          // Reset rounded corners
          btn.classList.remove('rounded-l-xl', 'rounded-r-xl');
        });

        // Add active classes to clicked button
        button.classList.add('bg-gradient-to-r', 'from-teal-500', 'to-teal-600', 'text-white');
        button.classList.remove('text-gray-600', 'hover:bg-gray-200');

        // Add rounded corners based on position
        if (button === buttons[0]) {
          button.classList.add('rounded-l-xl');
        } else if (button === buttons[buttons.length - 1]) {
          button.classList.add('rounded-r-xl');
        }

        const selectedType = button.getAttribute('data-type');
        const rideTypeInput = document.querySelector('input[name="ride_type"]');
        if (rideTypeInput) rideTypeInput.value = selectedType;
        const pickup = document.querySelector('input[name="pickup"]').value;
        const dropoff = document.querySelector('input[name="dropoff"]').value;
        const date = document.querySelector('input[name="ride_date"]').value;
        const time = document.querySelector('input[name="ride_time"]').value;
        const rentalSelect = document.querySelector('select[name="rental_duration"]');
        const rentalDuration = rentalSelect ? rentalSelect.value : '';
        
        if (pickup && dropoff && date && time) {
          // Get coordinates from hidden fields if available
          const pickupLat = document.getElementById('pickup_lat')?.value || '';
          const pickupLng = document.getElementById('pickup_lng')?.value || '';
          const dropLat = document.getElementById('drop_lat')?.value || '';
          const dropLng = document.getElementById('drop_lng')?.value || '';
          const distanceKm = document.getElementById('distance_km')?.value || '';
          const durationMin = document.getElementById('duration_min')?.value || '';
          
          let url = `/passenger/choose-ride/?pickup=${encodeURIComponent(pickup)}&dropoff=${encodeURIComponent(dropoff)}&ride_date=${date}&ride_time=${time}&ride_type=${selectedType}`;
          
          // Add coordinates if available
          if (pickupLat && pickupLng) {
            url += `&pickup_lat=${pickupLat}&pickup_lng=${pickupLng}`;
          }
          if (dropLat && dropLng) {
            url += `&drop_lat=${dropLat}&drop_lng=${dropLng}`;
          }
          if (distanceKm) {
            url += `&distance_km=${distanceKm}`;
          }
          if (durationMin) {
            url += `&duration_min=${durationMin}`;
          }
          if (pickupCity && pickupCity.value) {
            url += `&pickup_city=${encodeURIComponent(pickupCity.value)}`;
          }
          if (pickupDistrict && pickupDistrict.value) {
            url += `&pickup_district=${encodeURIComponent(pickupDistrict.value)}`;
          }
          if (pickupState && pickupState.value) {
            url += `&pickup_state=${encodeURIComponent(pickupState.value)}`;
          }
          if (dropCity && dropCity.value) {
            url += `&drop_city=${encodeURIComponent(dropCity.value)}`;
          }
          if (dropDistrict && dropDistrict.value) {
            url += `&drop_district=${encodeURIComponent(dropDistrict.value)}`;
          }
          if (dropState && dropState.value) {
            url += `&drop_state=${encodeURIComponent(dropState.value)}`;
          }
          
          if (selectedType === 'rental' && rentalDuration) {
            url += `&rental_duration=${rentalDuration}`;
          }
          window.location.href = url;
        }
        applyServiceFilter();
      });
    });

    const serviceRadios = document.querySelectorAll('input[name="selected_service"]');
    const bookButton = document.getElementById('book-ride-btn');

    function applyServiceFilter() {
      const rideTypeInput = document.querySelector('input[name="ride_type"]');
      const rideType = rideTypeInput ? rideTypeInput.value.toLowerCase() : '';
      serviceRadios.forEach(radio => {
        const label = radio.closest('label');
        const serviceName = (radio.dataset.serviceName || '').toLowerCase();
        const shouldHide = rideType === 'outstation' && outstationDisallowed.includes(serviceName);
        if (label) {
          label.style.display = shouldHide ? 'none' : '';
        }
        radio.disabled = shouldHide;
        if (shouldHide && radio.checked) {
          radio.checked = false;
          if (bookButton) bookButton.disabled = true;
        }
      });
    }

    serviceRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        if (radio.checked) {
          bookButton.disabled = false;
          bookButton.dataset.selectedService = radio.value;
        }
      });
    });

    applyServiceFilter();

    bookButton.addEventListener('click', () => {
      const rideTypeInput = document.querySelector('input[name="ride_type"]');
      const selectedRideType = normalizeText(rideTypeInput ? rideTypeInput.value : '');
      const selectedService = document.querySelector('input[name="selected_service"]:checked');
      if (!selectedService) {
        alert('Please select a service option before booking.');
        return;
      }
      const distanceKmValue = document.getElementById('distance_km')?.value || '';
      const durationMinValue = document.getElementById('duration_min')?.value || '';
      if (!distanceKmValue || !durationMinValue) {
        setNotice('Unable to calculate route distance. Please choose suggested locations and try again.', 'error');
        return;
      }

      // Capture selected service name and fare
      const selectedServiceContainer = selectedService.closest('label').querySelector('div.flex-1 p.font-semibold');
      const selectedFareContainer = selectedService.closest('label').querySelector('div.text-right p.text-teal-600');
      const selectedServiceName = selectedServiceContainer ? selectedServiceContainer.textContent.trim() : '';
      const selectedFare = selectedFareContainer ? selectedFareContainer.textContent.replace('₹', '').trim() : '';

      const pickup = document.querySelector('input[name="pickup"]').value;
      const dropoff = document.querySelector('input[name="dropoff"]').value;
      const ride_date = document.querySelector('input[name="ride_date"]').value;
      const ride_time = document.querySelector('input[name="ride_time"]').value;
      const ride_type = document.querySelector('input[name="ride_type"]').value;
      const rentalSelect = document.querySelector('select[name="rental_duration"]');
      const rental_duration = rentalSelect ? rentalSelect.value : '';

      function proceedToBooking() {
        let url = `/passenger/book-ride/?pickup=${encodeURIComponent(pickup)}&dropoff=${encodeURIComponent(dropoff)}&ride_date=${ride_date}&ride_time=${ride_time}&ride_type=${ride_type}&service_id=${selectedService.value}&service_name=${encodeURIComponent(selectedServiceName)}&fare=${encodeURIComponent(selectedFare)}`;
        const distanceKmValue = document.getElementById('distance_km')?.value || '';
        const durationMinValue = document.getElementById('duration_min')?.value || '';
        if (pickupCity && pickupCity.value) {
          url += `&pickup_city=${encodeURIComponent(pickupCity.value)}`;
        }
        if (pickupDistrict && pickupDistrict.value) {
          url += `&pickup_district=${encodeURIComponent(pickupDistrict.value)}`;
        }
        if (pickupState && pickupState.value) {
          url += `&pickup_state=${encodeURIComponent(pickupState.value)}`;
        }
        if (dropCity && dropCity.value) {
          url += `&drop_city=${encodeURIComponent(dropCity.value)}`;
        }
        if (dropDistrict && dropDistrict.value) {
          url += `&drop_district=${encodeURIComponent(dropDistrict.value)}`;
        }
        if (dropState && dropState.value) {
          url += `&drop_state=${encodeURIComponent(dropState.value)}`;
        }
        if (distanceKmValue) {
          url += `&distance_km=${encodeURIComponent(distanceKmValue)}`;
        }
        if (durationMinValue) {
          url += `&duration_min=${encodeURIComponent(durationMinValue)}`;
        }
        if (ride_type === 'rental' && rental_duration) {
          url += `&rental_duration=${rental_duration}`;
        }
        window.location.href = url;
      }

      function validateBeforeBooking() {
        if (selectedRideType !== 'daily') {
          setNotice('', 'success');
          proceedToBooking();
          return;
        }

        const pickupMeta = { city: pickupCity ? pickupCity.value : '', district: pickupDistrict ? pickupDistrict.value : '', state: pickupState ? pickupState.value : '' };
        const dropoffMeta = { city: dropCity ? dropCity.value : '', district: dropDistrict ? dropDistrict.value : '', state: dropState ? dropState.value : '' };
        const decision = isDailyAllowed(pickupMeta, dropoffMeta);
        const distanceKmValue = parseFloat(document.getElementById('distance_km')?.value || '');
        if (applyDistanceRule(distanceKmValue)) {
          return;
        }

        if (decision.allowed === null) {
          Promise.all([geocodeWithAddress(pickup), geocodeWithAddress(dropoff)])
            .then(([pickupResult, dropoffResult]) => {
              const pickupParts = extractAddressParts(pickupResult);
              const dropParts = extractAddressParts(dropoffResult);
              if (pickupCity) pickupCity.value = pickupParts.city || '';
              if (pickupDistrict) pickupDistrict.value = pickupParts.district || '';
              if (pickupState) pickupState.value = pickupParts.state || '';
              if (dropCity) dropCity.value = dropParts.city || '';
              if (dropDistrict) dropDistrict.value = dropParts.district || '';
              if (dropState) dropState.value = dropParts.state || '';

              const recheck = isDailyAllowed(pickupParts, dropParts);
              const refreshedDistance = parseFloat(document.getElementById('distance_km')?.value || '');
              if (applyDistanceRule(refreshedDistance)) {
                return;
              }
              if (recheck.allowed === false) {
                setNotice('Daily Ride is only available within the same city/service area. Please switch to Outstation or update locations.', 'error');
                const outstationBtn = document.querySelector('#ride-type-tabs [data-type="outstation"]');
                if (outstationBtn) outstationBtn.click();
                return;
              }
              if (recheck.allowed === null) {
                setNotice('We could not confirm city/state for the locations. Please choose from suggestions.', 'info');
                return;
              }
              setNotice('', 'success');
              proceedToBooking();
            })
            .catch(() => {
              setNotice('Unable to validate locations for Daily Ride. Please select suggested locations.', 'info');
            });
          return;
        }

        if (decision.allowed === false) {
          setNotice('Daily Ride is only available within the same city/service area. Please switch to Outstation or update locations.', 'error');
          const outstationBtn = document.querySelector('#ride-type-tabs [data-type="outstation"]');
          if (outstationBtn) outstationBtn.click();
          return;
        }
        setNotice('', 'success');
        proceedToBooking();
      }

      validateBeforeBooking();
    });
  });
</script>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    const pickupInput = document.querySelector('input[name="pickup"]').value;
    const dropoffInput = document.querySelector('input[name="dropoff"]').value;
    const mapContainer = document.getElementById('ride-map');
    const distanceBadge = document.getElementById('route-distance');
    const distanceField = document.getElementById('distance_km');
    const durationField = document.getElementById('duration_min');
    const rideTypeTabs = document.getElementById('ride-type-tabs');
    const outstationThresholdKm = rideTypeTabs && rideTypeTabs.dataset.outstationKm ? parseFloat(rideTypeTabs.dataset.outstationKm) : 40;

    if (!mapContainer) return;

    const map = L.map('ride-map', { scrollWheelZoom: false });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Basic initial view (India center fallback)
    map.setView([20.5937, 78.9629], 5);

    if (!pickupInput || !dropoffInput) {
      // No locations yet; nothing to route
      return;
    }

    function geocode(place) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(place)}&limit=1`;
      return fetch(url, { headers: { 'Accept': 'application/json' } })
        .then(r => r.json())
        .then(res => {
          if (Array.isArray(res) && res.length) {
            // Nominatim returns lat and lon, ensure we use [lat, lng] format for Leaflet
            const lat = parseFloat(res[0].lat);
            const lon = parseFloat(res[0].lon);
            console.log('Geocoded:', place, '->', [lat, lon]); // Debug log
            if (isNaN(lat) || isNaN(lon)) {
              throw new Error('Invalid coordinates');
            }
            return [lat, lon]; // [latitude, longitude] - correct for Leaflet
          }
          throw new Error('No results');
        });
    }

    Promise.all([geocode(pickupInput), geocode(dropoffInput)])
      .then(([pickupLatLng, dropoffLatLng]) => {
        // Validate coordinates
        if (!Array.isArray(pickupLatLng) || !Array.isArray(dropoffLatLng) ||
            pickupLatLng.length !== 2 || dropoffLatLng.length !== 2) {
          console.error('Invalid coordinate arrays:', pickupLatLng, dropoffLatLng);
          return;
        }

        // Ensure coordinates are numbers
        const pickupLat = parseFloat(pickupLatLng[0]);
        const pickupLng = parseFloat(pickupLatLng[1]);
        const dropoffLat = parseFloat(dropoffLatLng[0]);
        const dropoffLng = parseFloat(dropoffLatLng[1]);

        if (isNaN(pickupLat) || isNaN(pickupLng) || isNaN(dropoffLat) || isNaN(dropoffLng)) {
          console.error('Invalid coordinate values:', { pickupLatLng, dropoffLatLng });
          return;
        }

        // Create LatLng objects with correct [lat, lng] order
        const pickupLatLngObj = L.latLng(pickupLat, pickupLng);
        const dropoffLatLngObj = L.latLng(dropoffLat, dropoffLng);

        console.log('Creating markers at:', { pickup: [pickupLat, pickupLng], dropoff: [dropoffLat, dropoffLng] });

        // Create custom markers
        const pickupIcon = L.divIcon({
          className: 'custom-pickup-marker',
          html: '<div style="background: #10b981; width: 30px; height: 30px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>',
          iconSize: [30, 30],
          iconAnchor: [15, 30]
        });

        const dropoffIcon = L.divIcon({
          className: 'custom-dropoff-marker',
          html: '<div style="background: #dc2626; width: 30px; height: 30px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>',
          iconSize: [30, 30],
          iconAnchor: [15, 30]
        });

        const pickupMarker = L.marker(pickupLatLngObj, { icon: pickupIcon }).addTo(map).bindPopup('Pickup');
        const dropoffMarker = L.marker(dropoffLatLngObj, { icon: dropoffIcon }).addTo(map).bindPopup('Dropoff');

        const control = L.Routing.control({
          waypoints: [
            pickupLatLngObj,
            dropoffLatLngObj
          ],
          router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1' }),
          addWaypoints: false,
          draggableWaypoints: false,
          fitSelectedRoutes: true,
          show: false,
          lineOptions: {
            styles: [
              { color: '#14b8a6', opacity: 0.9, weight: 6 },
              { color: '#0f766e', opacity: 0.7, weight: 2 }
            ]
          }
        }).addTo(map);

        control.on('routesfound', function (e) {
          const route = e.routes && e.routes[0];
          if (!route) return;
          const meters = route.summary.totalDistance || 0;
          const seconds = route.summary.totalTime || 0;
          const km = (meters / 1000).toFixed(2);
          distanceBadge.textContent = `Distance: ${km} km`;
          distanceBadge.classList.remove('hidden');
          if (distanceField) distanceField.value = km;
          if (durationField) durationField.value = Math.round(seconds / 60).toString();

          // Also expose distance for other scripts if needed
          window.__routeDistanceKm = km;

          // Ensure bounds fit nicely using route coordinates (more reliable than only markers)
          const coordinates = route.coordinates || [];
          if (coordinates.length) {
            // Route coordinates from OSRM are in [lat, lng] format
            const latLngs = coordinates.map(c => {
              // Handle both {lat, lng} object and [lat, lng] array formats
              if (Array.isArray(c)) {
                return L.latLng(c[0], c[1]); // [lat, lng]
              } else if (c.lat !== undefined && c.lng !== undefined) {
                return L.latLng(c.lat, c.lng); // {lat, lng}
              } else if (c.latitude !== undefined && c.longitude !== undefined) {
                return L.latLng(c.latitude, c.longitude); // {latitude, longitude}
              }
              console.warn('Unknown coordinate format:', c);
              return null;
            }).filter(c => c !== null);
            
            if (latLngs.length > 0) {
              const routeBounds = L.latLngBounds(latLngs);
              map.fitBounds(routeBounds.pad(0.25));
            } else {
              const group = new L.FeatureGroup([pickupMarker, dropoffMarker]);
              map.fitBounds(group.getBounds().pad(0.25));
            }
          } else {
            const group = new L.FeatureGroup([pickupMarker, dropoffMarker]);
            map.fitBounds(group.getBounds().pad(0.25));
          }

          // Invalidate size after fitting to ensure proper rendering
          setTimeout(() => map.invalidateSize(), 100);
        });

        control.on('routingerror', function (e) {
          console.warn('Routing error:', e);
          if (distanceField) distanceField.value = '';
          if (durationField) durationField.value = '';
          distanceBadge.textContent = 'Distance unavailable';
          distanceBadge.classList.remove('hidden');

          const group = new L.FeatureGroup([pickupMarker, dropoffMarker]);
          map.fitBounds(group.getBounds().pad(0.25));
          setTimeout(() => map.invalidateSize(), 100);
        });

        function syncRideTypeWithDistance(kmValue) {
          if (!kmValue || isNaN(kmValue)) return;
          const rideTypeInput = document.querySelector('input[name="ride_type"]');
          const selectedRideType = rideTypeInput ? rideTypeInput.value.toLowerCase() : '';
          if (selectedRideType === 'daily' && kmValue >= outstationThresholdKm) {
            const outstationBtn = document.querySelector('#ride-type-tabs [data-type="outstation"]');
            if (outstationBtn) outstationBtn.click();
          }
        }

        control.on('routesfound', function (e) {
          const route = e.routes && e.routes[0];
          if (!route) return;
          const kmValue = (route.summary.totalDistance || 0) / 1000;
          syncRideTypeWithDistance(kmValue);
        });

        control.on('routingerror', function () {
          return;
        });
      })
      .catch(() => {
        // If geocoding fails, no-op
      });

    // Invalidate size after initial render and when tiles finish loading
    setTimeout(() => map.invalidateSize(), 300);
    map.whenReady(() => setTimeout(() => map.invalidateSize(), 100));
    map.on('load', () => setTimeout(() => map.invalidateSize(), 50));
    window.addEventListener('resize', () => map.invalidateSize());
  });
</script>
{% endblock %}
